//-----------------------------------------------------------------------------
// A Cloudflare Worker/Pages-based Trojan Proxy
// ProxyIP and WebSocket Transport
// By Dr. Upendra
//-----------------------------------------------------------------------------
import { connect } from "cloudflare:sockets";

// Global reusable encoder/decoder.
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();

// Environment variables â€” defaults only; actual values are local per-request.
// These are kept as module-level vars for functions that read them
// (buildTrojanLink, isValidPassword, etc.). The fetch handler always
// writes them before any request logic runs.
let password = "";
let sha224Password;
let proxyIP = "";
let keepaliveMs = 0;
let enableECH = true;
let customDNS = 'https://cloudflare-dns.com/dns-query';
let customECHDomain = 'cloudflare-ech.com';

// Global variable to store ECH debug info
let echDebugInfo = '';

// Subscription converter URL (can be overridden via KV key 'SCU')
let scu = 'https://url.v1.mk/sub';
// Remote Clash rule config URL
const remoteConfigUrl = 'https://raw.githubusercontent.com/byJoey/test/refs/heads/main/tist.ini';

//-----------------------------------------------------------------------------
// Backup ProxyIP pool â€” nearest server selected automatically per request
// These are the same CMLiussss relay domains used by Index.js.
// When no PROXYIP env var / KV override is set, the worker picks the closest
// one based on the Cloudflare data-centre country that handled the request.
//-----------------------------------------------------------------------------
const backupIPs = [
  { domain: 'ProxyIP.US.CMLiussss.net',           regionCode: 'US',           port: 443 },
  { domain: 'ProxyIP.SG.CMLiussss.net',           regionCode: 'SG',           port: 443 },
  { domain: 'ProxyIP.JP.CMLiussss.net',           regionCode: 'JP',           port: 443 },
  { domain: 'ProxyIP.KR.CMLiussss.net',           regionCode: 'KR',           port: 443 },
  { domain: 'ProxyIP.DE.CMLiussss.net',           regionCode: 'DE',           port: 443 },
  { domain: 'ProxyIP.SE.CMLiussss.net',           regionCode: 'SE',           port: 443 },
  { domain: 'ProxyIP.NL.CMLiussss.net',           regionCode: 'NL',           port: 443 },
  { domain: 'ProxyIP.FI.CMLiussss.net',           regionCode: 'FI',           port: 443 },
  { domain: 'ProxyIP.GB.CMLiussss.net',           regionCode: 'GB',           port: 443 },
  { domain: 'ProxyIP.Oracle.cmliussss.net',       regionCode: 'Oracle',       port: 443 },
  { domain: 'ProxyIP.DigitalOcean.CMLiussss.net', regionCode: 'DigitalOcean', port: 443 },
  { domain: 'ProxyIP.Vultr.CMLiussss.net',        regionCode: 'Vultr',        port: 443 },
  { domain: 'ProxyIP.Multacom.CMLiussss.net',     regionCode: 'Multacom',     port: 443 },
];

// Cached for the lifetime of the isolate so region detection only runs once
// per cold-start, not on every request.
let currentWorkerRegion = '';

/**
 * Derive the Cloudflare data-centre region from request.cf.country.
 * Falls back to 'SG' (geographically central) if undetermined.
 * Identical mapping to Index.js detectWorkerRegion().
 */
function detectWorkerRegion(request) {
  try {
    const country = request.cf?.country;
    if (country) {
      const map = {
        'US': 'US', 'CA': 'US',
        'SG': 'SG', 'AU': 'SG', 'CN': 'SG',
        'JP': 'JP', 'TW': 'JP',
        'KR': 'KR',
        'DE': 'DE', 'FR': 'DE', 'IT': 'DE', 'ES': 'DE', 'CH': 'DE', 'AT': 'DE',
        'NL': 'NL', 'BE': 'NL',
        'SE': 'SE', 'DK': 'SE', 'NO': 'SE',
        'FI': 'FI',
        'GB': 'GB', 'IE': 'GB',
      };
      if (map[country]) return map[country];
    }
  } catch (_) {}
  return 'SG';
}

/**
 * Regions geographically adjacent to each primary region.
 * Used to build a priority order: exact match â†’ nearby â†’ everything else.
 */
function getNearbyRegions(region) {
  const nearby = {
    'US': ['SG', 'JP', 'KR'],
    'SG': ['JP', 'KR', 'US'],
    'JP': ['SG', 'KR', 'US'],
    'KR': ['JP', 'SG', 'US'],
    'DE': ['NL', 'GB', 'SE', 'FI'],
    'SE': ['DE', 'NL', 'FI', 'GB'],
    'NL': ['DE', 'GB', 'SE', 'FI'],
    'FI': ['SE', 'DE', 'NL', 'GB'],
    'GB': ['DE', 'NL', 'SE', 'FI'],
  };
  return nearby[region] || [];
}

/**
 * Full ordered region list: exact match first, then nearby, then the rest.
 */
function getAllRegionsByPriority(region) {
  const nearby = getNearbyRegions(region);
  const all = ['US', 'SG', 'JP', 'KR', 'DE', 'SE', 'NL', 'FI', 'GB'];
  return [region, ...nearby, ...all.filter(r => r !== region && !nearby.includes(r))];
}

/**
 * Sort backupIPs by proximity to workerRegion.
 * Provider-only entries (Oracle, DigitalOcean, Vultr, Multacom) are appended
 * last since they have no geographic regionCode to match against.
 */
function getSortedBackupIPs(workerRegion) {
  if (!workerRegion) return [...backupIPs];
  const priority = getAllRegionsByPriority(workerRegion);
  const geoIPs      = backupIPs.filter(ip => priority.includes(ip.regionCode));
  const providerIPs = backupIPs.filter(ip => !priority.includes(ip.regionCode));
  // Sort geo IPs by their position in the priority list
  geoIPs.sort((a, b) => priority.indexOf(a.regionCode) - priority.indexOf(b.regionCode));
  return [...geoIPs, ...providerIPs];
}

/**
 * Return the single best backup ProxyIP for the given worker region.
 * Returns { domain, port } or null if the pool is empty (shouldn't happen).
 */
function getBestBackupIP(workerRegion) {
  const sorted = getSortedBackupIPs(workerRegion);
  return sorted.length > 0 ? sorted[0] : null;
}

//-----------------------------------------------------------------------------
// KV Store â€” runtime config that overrides env vars without redeployment
// Bind a KV namespace to env.KV in wrangler.toml.
// Stores a single JSON blob under key 'c' with the following relevant fields:
//   PROXYIP    â€” proxyIP override  (host:port)
//   ECH        â€” ECH enabled flag  ('yes' | 'no')  [default: yes]
//   DOH        â€” DNS-over-HTTPS URL
//   ECH_DOMAIN â€” ECH domain for HTTPS record queries
//   KEEPALIVE  â€” keepalive interval in ms
//   PASSWORD   â€” password/token override
//   DKBY       â€” auto-set to 'yes' when ECH is enabled
//-----------------------------------------------------------------------------
let kvStore = null;
let kvConfig = {};

//-----------------------------------------------------------------------------
// KV Helpers
//-----------------------------------------------------------------------------

/**
 * Initialise the KV store from env.KV.
 * Silently no-ops if not bound â€” env vars remain the source of truth.
 */
async function initKVStore(env) {
  const ns = env.KV || null;
  if (!ns) { kvStore = null; kvConfig = {}; return; }
  try {
    kvStore = ns;
    await loadKVConfig();
  } catch (err) {
    console.warn("KV init failed (continuing without KV):", err.message);
    kvStore = null;
    kvConfig = {};
  }
}

/** Load the single config blob from KV. Safe to call multiple times. */
async function loadKVConfig() {
  if (!kvStore) return;
  try {
    const raw = await kvStore.get('c');
    kvConfig = raw ? JSON.parse(raw) : {};
  } catch (err) {
    console.warn("KV load failed:", err.message);
    kvConfig = {};
  }
}

/** Persist the in-memory kvConfig blob back to KV. */
async function saveKVConfig() {
  if (!kvStore) throw new Error("KV not available");
  await kvStore.put('c', JSON.stringify(kvConfig));
}

/**
 * Read a config value.
 * Priority: KV > envValue > defaultValue
 * @param {string}  key          - KV key name
 * @param {string}  [envValue]   - Fallback from env var
 * @param {string}  [defaultVal] - Final fallback
 */
function getKV(key, envValue = '', defaultVal = '') {
  if (kvConfig[key] !== undefined && kvConfig[key] !== null) return kvConfig[key];
  if (envValue !== undefined && envValue !== null && envValue !== '') return envValue;
  return defaultVal;
}

/**
 * Write a single value to KV (also persists the full blob).
 * Silently no-ops if KV is not bound.
 */
async function setKV(key, value) {
  kvConfig[key] = value;
  try { await saveKVConfig(); } catch (err) {
    console.warn(`KV write failed for key "${key}":`, err.message);
  }
}

//-----------------------------------------------------------------------------
// Main Worker Fetch Handler
//-----------------------------------------------------------------------------
/**
 * The default Worker handler.
 */
export default {
  async fetch(request, env, ctx) {
    try {
      // 1. Init KV first â€” it overrides env vars for all config below
      await initKVStore(env);

      // 2. Password â€” KV key 'PASSWORD' can override the env PASSWORD at runtime
      password = getKV('PASSWORD', env.PASSWORD || env.pswd || env.UUID || env.uuid || env.TOKEN);
      if (!password) {
        throw new Error("Missing required PASSWORD/UUID/TOKEN environment variable.");
      }

      sha224Password = env.SHA224 || env.SHA224PASS || sha224(password);
      
      // 3. Keepalive â€” KV key 'KEEPALIVE' overrides KEEPALIVE_MS
      keepaliveMs = Number(getKV('KEEPALIVE', env.KEEPALIVE_MS, 0)) || 0;

      // 4. ProxyIP â€” KV key 'PROXYIP' overrides PROXYIP env var.
      // If neither is set, automatically pick the nearest backupIP from the pool.
      proxyIP = getKV('PROXYIP', env.PROXYIP || env.proxyip || "");

      // Detect (and cache) the worker region once per isolate lifetime
      if (!currentWorkerRegion) {
        currentWorkerRegion = detectWorkerRegion(request);
      }

      // Auto-select nearest backupIP when no explicit PROXYIP is configured
      if (!proxyIP) {
        const best = getBestBackupIP(currentWorkerRegion);
        if (best) {
          proxyIP = `${best.domain}:${best.port}`;
          console.log(`[ProxyIP] No PROXYIP set â€” auto-selected nearest: ${proxyIP} (region: ${currentWorkerRegion})`);
        }
      }

      // 5. ECH â€” KV key 'ECH' overrides env; default is ON (true)
      const echVal = getKV('ECH', env.ECH || env.ech, 'yes');
      enableECH = echVal !== 'no' && echVal !== 'false' && echVal !== '0';

      // 6. DOH and ECH_DOMAIN â€” KV keys override env vars
      customDNS = getKV('DOH', env.DOH || env.CUSTOM_DNS || env.customDNS, 'https://cloudflare-dns.com/dns-query');
      customECHDomain = getKV('ECH_DOMAIN', env.ECH_DOMAIN || env.CUSTOM_ECH_DOMAIN || env.customECHDomain, 'cloudflare-ech.com');

      // 7. If ECH is enabled, auto-persist DKBY=yes to KV
      if (enableECH && getKV('DKBY', '', '') !== 'yes') {
        await setKV('DKBY', 'yes');
      }

      // 8. Validate PROXYIP â€” warn and clear instead of hard-crashing the worker
      if (proxyIP && !/^(?:[a-zA-Z0-9.-]+|\[[a-fA-F0-9:]+\]):\d+$/.test(proxyIP)) {
        console.warn(`Invalid PROXYIP format: "${proxyIP}". Clearing â€” will retry direct on failure.`);
        proxyIP = "";
      }

      const reqUrl = new URL(request.url);

      // Serve homepage if root path.
      if (reqUrl.pathname === "/") {
        return serveHomepage(env);
      }

      // Trojan configuration page: /<password>
      // Returns a styled HTML page showing the trojan link, V2Ray sub link, and Clash sub link.
      if (reqUrl.pathname === `/${password}`) {
        const hostName = request.headers.get("Host") || "example.com";
        return new Response(serveConfigPage(password, hostName), {
          status: 200,
          headers: {
            "Content-Type": "text/html;charset=utf-8",
            "X-ECH-Status": "ENABLED",
          },
        });
      }

      // Subscription endpoint: /<password>/sub
      // ?target=clash  â†’ Clash YAML via converter
      // ?target=base64 â†’ raw base64 (used internally by clash converter)
      // default        â†’ base64 nodes (V2Ray / universal)
      if (reqUrl.pathname === `/${password}/sub`) {
        const hostName = request.headers.get("Host") || "example.com";
        const target = (reqUrl.searchParams.get("target") || "").toLowerCase();
        const nodes = generateTrojanNodes(password, hostName);
        const base64Content = btoa(nodes.join("\n"));

        if (target === "clash") {
          try {
            const clashYaml = await generateClashConfig(nodes, request, password, hostName);
            return new Response(clashYaml, {
              status: 200,
              headers: {
                "Content-Type": "text/yaml;charset=utf-8",
                "Cache-Control": "no-store",
                "X-ECH-Status": "ENABLED",
              },
            });
          } catch (err) {
            return new Response(`# Clash config generation failed: ${err.message}`, {
              status: 502,
              headers: { "Content-Type": "text/yaml;charset=utf-8" },
            });
          }
        }

        return new Response(base64Content, {
          status: 200,
          headers: {
            "Content-Type": "text/plain;charset=utf-8",
            "Cache-Control": "no-store",
            "X-ECH-Status": "ENABLED",
          },
        });
      }

      // ECH status/debug endpoint: /<password>/ech-status
      if (reqUrl.pathname === `/${password}/ech-status`) {
        const statusInfo = {
          echEnabled: true,
          customDNS,
          customECHDomain,
          debugInfo: echDebugInfo || 'ECH enabled',
        };
        return new Response(JSON.stringify(statusInfo, null, 2), {
          status: 200,
          headers: { "Content-Type": "application/json;charset=utf-8" },
        });
      }

      // KV config API: /<password>/config
      // GET  â†’ returns current effective config (KV values shown, env defaults where KV is absent)
      // POST â†’ accepts JSON body with any subset of: { p, ech, customDNS, customECHDomain, keepalive, tp }
      //        Writes to KV; takes effect on next request without redeployment.
      //        Send a key with value "" or null to delete it from KV (env var fallback resumes).
      if (reqUrl.pathname === `/${password}/config`) {
        if (!kvStore) {
          return new Response(JSON.stringify({
            error: "KV not configured. Bind a KV namespace to the 'KV' (or 'C') variable in wrangler.toml.",
            kvEnabled: false,
          }), { status: 503, headers: { "Content-Type": "application/json" } });
        }

        if (request.method === "GET") {
          return new Response(JSON.stringify({
            kvEnabled: true,
            config: {
              PROXYIP:    { value: proxyIP,                       source: kvConfig.PROXYIP    !== undefined ? "kv" : (env.PROXYIP ? "env" : "auto-backupIP") },
              ECH:        { value: enableECH ? 'yes' : 'no',      source: kvConfig.ECH        !== undefined ? "kv" : "env" },
              DOH:        { value: customDNS,                     source: kvConfig.DOH        !== undefined ? "kv" : "env" },
              ECH_DOMAIN: { value: customECHDomain,               source: kvConfig.ECH_DOMAIN !== undefined ? "kv" : "env" },
              KEEPALIVE:  { value: keepaliveMs,                   source: kvConfig.KEEPALIVE  !== undefined ? "kv" : "env" },
              PASSWORD:   { value: "[hidden]",                    source: kvConfig.PASSWORD   !== undefined ? "kv" : "env" },
              DKBY:       { value: kvConfig.DKBY || 'not set',    source: kvConfig.DKBY       !== undefined ? "kv" : "env" },
            },
            workerRegion: currentWorkerRegion,
            backupIPPool: getSortedBackupIPs(currentWorkerRegion).map(b => `${b.domain}:${b.port}`),
            rawKV: { ...kvConfig, PASSWORD: kvConfig.PASSWORD ? "[hidden]" : undefined },
          }, null, 2), { status: 200, headers: { "Content-Type": "application/json" } });
        }

        if (request.method === "POST") {
          try {
            const updates = await request.json();
            const allowed = new Set(['PROXYIP', 'ECH', 'DOH', 'ECH_DOMAIN', 'KEEPALIVE', 'PASSWORD', 'DKBY']);
            for (const [key, value] of Object.entries(updates)) {
              if (!allowed.has(key)) continue; // silently ignore unknown keys
              if (value === "" || value === null || value === undefined) {
                delete kvConfig[key];
              } else {
                kvConfig[key] = value;
              }
            }
            await saveKVConfig();
            return new Response(JSON.stringify({
              success: true,
              message: "Config saved. Takes effect on next request.",
              savedKeys: Object.keys(updates).filter(k => allowed.has(k)),
            }), { status: 200, headers: { "Content-Type": "application/json" } });
          } catch (err) {
            return new Response(JSON.stringify({ success: false, error: err.message }),
              { status: 400, headers: { "Content-Type": "application/json" } });
          }
        }

        return new Response(JSON.stringify({ error: "Method not allowed" }),
          { status: 405, headers: { "Content-Type": "application/json" } });
      }

      // Validate WebSocket upgrade.
      const upgradeHeader = request.headers.get("Upgrade");
      const websocketKey = request.headers.get("sec-websocket-key");
      const allowedProtocols = ["ws", "wss", "voip"];
      const subprotocol = request.headers.get("sec-websocket-protocol") || "";

      if (!upgradeHeader || upgradeHeader.toLowerCase() !== "websocket" || !websocketKey) {
        return new Response(
          "This node is for WebSocket connections only. Use '/<your-password>' for Trojan configuration.",
          { status: 400, headers: { "Content-Type": "text/plain;charset=utf-8" } }
        );
      }

      if (subprotocol && !allowedProtocols.includes(subprotocol.toLowerCase())) {
        return new Response("Unsupported WebSocket subprotocol.", { status: 400 });
      }

      // Initiate Trojan-over-WebSocket handling.
      const trojanPromise = handleTrojanOverWS(request);
      ctx.waitUntil(trojanPromise);
      return await trojanPromise;
    } catch (err) {
      console.error("Global fetch error:", err);
      return new Response(err.toString(), { status: 500 });
    }
  },
};

//-----------------------------------------------------------------------------
// Handle Trojan-over-WebSocket Connections
//-----------------------------------------------------------------------------
/**
 * Handles Trojan-over-WebSocket connections.
 *
 * @param {Request} request - The WebSocket upgrade request.
 * @returns {Promise<Response>} A promise resolving to a WebSocket upgrade response.
 */
async function handleTrojanOverWS(request) {
  const webSocketPair = new WebSocketPair();
  const [client, webSocket] = Object.values(webSocketPair);
  
  try {
    webSocket.accept();
    webSocket.binaryType = "arraybuffer";
  } catch (error) {
    console.error("WebSocket handshake failure:", error);
    return new Response("WebSocket handshake error", { status: 400 });
  }

  let address = "";
  let portWithRandomLog = "";
  
  // Pre-computed random value to avoid repeated Math.random() calls
  const logId = Math.random().toFixed(4);
  
  const log = (info, event) => {
    console.log(`[${new Date().toISOString()}] [${address}:${portWithRandomLog}] ${info}`, event || "");
  };

  // Optimized keepalive with proper cleanup tracking
  let keepaliveTimer = null;
  let isActive = true;
  
  const startKeepalive = () => {
    if (Number.isFinite(keepaliveMs) && keepaliveMs > 0 && isActive) {
      keepaliveTimer = setInterval(() => {
        if (!isActive) {
          clearInterval(keepaliveTimer);
          return;
        }
        
        try {
          if (webSocket?.readyState === 1 /* WebSocket OPEN */) {
            webSocket.send("~keepalive~");
          } else {
            clearInterval(keepaliveTimer);
            keepaliveTimer = null;
          }
          
        } catch (e) {
          console.error("Keepalive send error:", e);
          clearInterval(keepaliveTimer);
          keepaliveTimer = null;
        }
      }, keepaliveMs);
    }
  };

  const stopKeepalive = () => {
    isActive = false;
    if (keepaliveTimer) {
      clearInterval(keepaliveTimer);
      keepaliveTimer = null;
    }
  };

  // Consolidated event handlers with optimized cleanup
  const handleClose = (evt) => {
    log(`websocket closed (code=${evt.code} reason=${evt.reason})`);
    stopKeepalive();
  };

  const handleError = (evt) => {
    log("websocket error", evt);
    stopKeepalive();
  };

  // Use { once: true } for cleanup events to prevent memory leaks
  webSocket.addEventListener("close", handleClose, { once: true });
  webSocket.addEventListener("error", handleError);

  startKeepalive();

  const earlyDataHeader = request.headers.get("sec-websocket-protocol") || "";
  const readableWebSocketStream = makeReadableWebSocketStream(webSocket, earlyDataHeader, log);
  const remoteSocketWrapper = { value: null };
  
  // Optimized main processing loop with better error handling
  const processStream = async () => {
    const reader = readableWebSocketStream.getReader();
    let headerParsed = false;
    // Persistent TCP writer â€” acquired once after header is parsed,
    // held open for the lifetime of the connection (avoids per-chunk lock churn).
    let tcpWriter = null;
    // Buffer for chunks that arrive while TCP connection is still being established.
    // handleTCPOutbound is called without await, so remoteSocketWrapper.value may
    // not be set yet when the next chunk arrives. Without this buffer those chunks
    // would fall through both if-branches and be silently dropped.
    let pendingChunks = [];
    
    try {
      while (isActive) {
        const result = await reader.read();
        if (result.done) break;
        
        const { value } = result;
        
        // Fast path: header parsed AND TCP socket is ready
        if (headerParsed && remoteSocketWrapper.value) {
          // Flush any buffered chunks first (only happens once per connection)
          if (pendingChunks.length > 0) {
            if (!tcpWriter) {
              try {
                tcpWriter = remoteSocketWrapper.value.writable.getWriter();
              } catch (err) {
                log("Failed to acquire TCP writer (flush)", err);
                break;
              }
            }
            for (const pending of pendingChunks) {
              try { await tcpWriter.write(pending); }
              catch (err) { log("Error flushing buffered chunk", err); break; }
            }
            pendingChunks = [];
          }
          // Lazily acquire the writer once and reuse it
          if (!tcpWriter) {
            try {
              tcpWriter = remoteSocketWrapper.value.writable.getWriter();
            } catch (err) {
              log("Failed to acquire TCP writer", err);
              break;
            }
          }
          try {
            await tcpWriter.write(value);
          } catch (err) {
            log("Error writing to TCP socket", err);
            break;
          }
          continue;
        }

        // Header parsed but TCP not ready yet â€” buffer the chunk, don't drop it
        if (headerParsed && !remoteSocketWrapper.value) {
          pendingChunks.push(value);
          continue;
        }

        // Header parsing path (only runs once)
        if (!headerParsed) {
          try {
            const {
              hasError,
              message,
              portRemote = 443,
              addressRemote = "",
              rawClientData,
              passwordFromClient,
            } = await parseTrojanHeader(value);

            address = addressRemote;
            portWithRandomLog = `${portRemote}--${logId}`;

            if (hasError) {
              throw new Error(`Header parse error for ${addressRemote}:${portRemote} - ${message}`);
            }

            if (!isValidPassword(passwordFromClient)) {
              throw new Error("invalid password");
            }

            if (!addressRemote) {
              throw new Error(`Invalid address received for port ${portRemote}`);
            }

            log(`Processing TCP outbound connection ${addressRemote}:${portRemote}`);
            
            // Mark header as parsed before handling TCP connection
            headerParsed = true;
            
            // Launch TCP setup asynchronously. Chunks arriving before
            // remoteSocketWrapper.value is set are buffered in pendingChunks above.
            handleTCPOutbound(remoteSocketWrapper, addressRemote, portRemote, rawClientData, webSocket, log);
            
          } catch (err) {
            log("Header parsing error", err);
            throw err;
          }
        }
      }
      
    } catch (err) {
      log("Error processing WebSocket stream", err);
      throw err;
    } 
    
    finally {
      pendingChunks = [];
      // Release persistent writer if acquired
      if (tcpWriter) {
        try { tcpWriter.releaseLock(); } catch {}
        tcpWriter = null;
      }
      // Ensure reader is always released
      try { reader.releaseLock(); } catch {}
      stopKeepalive();
      safeCloseWebSocket(webSocket);
    }
  };

  // Start processing without awaiting to avoid blocking response
  processStream().catch(err => {
    console.error("Stream processing failed:", err);
    stopKeepalive();
    safeCloseWebSocket(webSocket);
  });

  return new Response(null, { status: 101, webSocket: client });
}

//-----------------------------------------------------------------------------
// Password Validation (constant-time)
//-----------------------------------------------------------------------------
function constantTimeEqual(a, b) {
  if (typeof a !== "string" || typeof b !== "string") return false;
  const la = a.length, lb = b.length;
  let res = la === lb ? 0 : 1;
  const L = Math.max(la, lb);
  for (let i = 0; i < L; i++) {
    const ca = i < la ? a.charCodeAt(i) : 0;
    const cb = i < lb ? b.charCodeAt(i) : 0;
    res |= ca ^ cb;
  }
  return res === 0;
}

function isValidPassword(clientPwd) {
  if (!clientPwd) return false;
  try {
    if (constantTimeEqual(clientPwd, password)) return true;
    if (constantTimeEqual(clientPwd.toLowerCase(), sha224(password).toLowerCase())) return true;
  } catch {}
  return false;
}

//-----------------------------------------------------------------------------
// Trojan Header Parsing (variable-length password + CRLF, proper SOCKS layout)
//-----------------------------------------------------------------------------
/**
 * Trojan spec (classic/GFW):
 *   <PASSWORD><CRLF><CMD=0x01><ATYP><DST-ADDR><DST-PORT(2)><CRLF><DATA...>
 * ATYP: 0x01=IPv4 (4 bytes), 0x03=DOMAIN (1 len + name), 0x04=IPv6 (16 bytes)
 *
 * @param {ArrayBuffer} buffer
 * @returns {Promise<{hasError: boolean, message?: string, addressRemote?: string, portRemote?: number, rawClientData?: ArrayBuffer, passwordFromClient?: string}>}
 */
async function parseTrojanHeader(buffer) {
  if (!(buffer instanceof ArrayBuffer) || buffer.byteLength < 4) {
    return { hasError: true, message: "insufficient data" };
  }

  // 1) Extract password up to CRLF
  const { passwordFromClient, rest, error } = extractPasswordAndRest(buffer);
  if (error) return { hasError: true, message: error };

  // 2) Parse command + address
  const bytes = new Uint8Array(rest);
  if (bytes.length < 4) return { hasError: true, message: "invalid request data" };

  const cmd = bytes[0];
  if (cmd !== 0x01) {
    return { hasError: true, message: "unsupported command; only CONNECT (0x01) allowed" };
  }

  const atype = bytes[1];
  let idx = 2;
  let address = "";

  if (atype === 0x01) {
    // IPv4
    if (bytes.length < idx + 4) return { hasError: true, message: "truncated IPv4" };
    address = `${bytes[idx++]}.${bytes[idx++]}.${bytes[idx++]}.${bytes[idx++]}`;
  } else 
  
  if (atype === 0x03) {
    // DOMAIN
    if (bytes.length < idx + 1) return { hasError: true, message: "truncated domain length" };
    const len = bytes[idx++];
    if (bytes.length < idx + len) return { hasError: true, message: "truncated domain name" };
    address = textDecoder.decode(bytes.slice(idx, idx + len));
    idx += len;
  } else 
  
  if (atype === 0x04) {
    // IPv6
    if (bytes.length < idx + 16) return { hasError: true, message: "truncated IPv6" };
    const seg = [];
    for (let i = 0; i < 16; i += 2) {
      seg.push(((bytes[idx + i] << 8) | bytes[idx + i + 1]).toString(16));
    }
    address = seg.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3"); // simple compression
    idx += 16;
  } else 
  
  {
    return { hasError: true, message: `invalid address type ${atype}` };
  }

  // 3) Port (2 bytes, big-endian)
  if (bytes.length < idx + 2) return { hasError: true, message: "missing port" };
  const portRemote = (bytes[idx] << 8) | bytes[idx + 1];
  idx += 2;

  // 4) CRLF after port
  if (bytes.length < idx + 2) return { hasError: true, message: "missing CRLF after port" };
  if (!(bytes[idx] === 0x0d && bytes[idx + 1] === 0x0a)) {
    return { hasError: true, message: "invalid header format (CRLF after port missing)" };
  }
  idx += 2;

  // 5) Remaining data is the initial payload
  const rawClientData = bytes.slice(idx).buffer;

  return {
    hasError: false,
    addressRemote: address,
    portRemote,
    rawClientData,
    passwordFromClient,
  };
}

/**
 * Extract password and remaining bytes from a Trojan header buffer.
 * Looks for the first CRLF and splits there.
 */
function extractPasswordAndRest(buffer) {
  try {
    const bytes = new Uint8Array(buffer);
    const cr = 0x0d, lf = 0x0a;
    let idx = -1;
    for (let i = 0; i + 1 < bytes.length; i++) {
      if (bytes[i] === cr && bytes[i + 1] === lf) { idx = i; break; }
    }
    
    if (idx === -1) return { error: "invalid header format (CRLF missing)" };
    const pwdBytes = bytes.slice(0, idx);
    const rest = bytes.slice(idx + 2).buffer;
    const passwordFromClient = textDecoder.decode(pwdBytes);
    return { passwordFromClient, rest, error: null };
    
  } catch (e) {
    return { error: "password extraction error" };
  }
}

//-----------------------------------------------------------------------------
// Handle Outbound TCP: always use proxyIP if provided for constant speed
//-----------------------------------------------------------------------------
/**
 * Handles outbound TCP connections by establishing a connection and piping data.
 *
 * @param {{value: any}} remoteSocketWrapper - Wrapper for the remote socket.
 * @param {string} addressRemote - The target address.
 * @param {number} portRemote - The target port.
 * @param {ArrayBuffer} rawClientData - The initial data chunk from the client.
 * @param {WebSocket} webSocket - The WebSocket used for forwarding data.
 * @param {(msg: string, err?: any) => void} log - Logging callback.
 */
async function handleTCPOutbound(
  remoteSocketWrapper,
  addressRemote,
  portRemote,
  rawClientData,
  webSocket,
  log
) {
    
  /**
   * Connects to a TCP socket and writes initial data.
   * @param {string} address - Destination IP or hostname.
   * @param {number} port - Destination port.
   * @returns {Promise<any>} - The connected TCP socket.
   */
  const connectAndWrite = async (address, port) => {
    log(`Connecting to ${address}:${port}`);

    // TLS options for secure connection
    const tlsOptions = {
      minVersion: "TLSv1.3",
      maxVersion: "TLSv1.3",
      ciphers: "TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256",
      alpnProtocols: ["h3", "h2", "http/1.1"],
      servername: /^[0-9:.]+$/.test(address) ? undefined : address,
      honorCipherOrder: true,
      rejectUnauthorized: true,
    };

    const tryConnect = async () => {
      return connect({
        hostname: address,
        port,
        secureTransport: "on",
        tcpTurbo: true,
        tlsOptions,
        keepAlive: true,
      });
    };

    let tcpSocket;
    try {
      tcpSocket = await tryConnect();
    } catch (err) {
      const errStr = err.toString();

      // Keep retry on specific Cloudflare error "1101", but do NOT suppress logging.
      if (errStr.includes("1101")) {
        console.warn(`Cloudflare error 1101 for ${address}:${port}; retrying...`, err);

        try {
          tcpSocket = await tryConnect();
        } catch (retryErr) {
          console.error(`Retry failed for ${address}:${port}:`, retryErr);
          throw new Error(`Error connecting to ${address}:${port} after retry - ${retryErr}`);
        }
      } else {
        // Generic error
        throw new Error(`Error connecting to ${address}:${port} - ${errStr}`);
      }
    }

    remoteSocketWrapper.value = tcpSocket;
    
    // Best-effort TCP_NODELAY (low-latency small packets)
    try {
      if (typeof tcpSocket.setNoDelay === "function") {
        tcpSocket.setNoDelay(true);
      } else if (tcpSocket.socket && typeof tcpSocket.socket.setNoDelay === "function") {
        tcpSocket.socket.setNoDelay(true);
      }
      
    } catch (e) {
      // Not fatal; just sample-log.
      log("setNoDelay failed (non-fatal)");
    }

    const writer = tcpSocket.writable.getWriter();
    try {
      await writer.write(rawClientData);
    } catch (err) {
      log("Error writing initial data to TCP socket", err);
      throw err;
    } finally {
      writer.releaseLock();
    }
    return tcpSocket;
  };

  /**
   * Parses a proxyIP string ("host:port" or "[ipv6]:port") into {host, port}.
   * Returns null if the string is empty/invalid instead of throwing,
   * so callers can decide gracefully what to do.
   */
  const parseProxyIP = (proxy) => {
    if (!proxy || !proxy.trim()) return null;

    // IPv6 with brackets: [::1]:443
    const ipv6Match = proxy.match(/^\[(.+)]:(\d+)$/);
    if (ipv6Match) {
      return { host: ipv6Match[1], port: Number(ipv6Match[2]) };
    }

    // IPv4 or hostname with port: example.com:443
    const lastColon = proxy.lastIndexOf(":");
    if (lastColon > 0) {
      const host = proxy.substring(0, lastColon);
      const port = Number(proxy.substring(lastColon + 1));
      if (!isNaN(port) && port > 0 && port <= 65535) {
        return { host, port };
      }
    }

    return null;
  };

  /**
   * Plain (non-TLS) connect + write â€” used for proxyIP relay connections.
   * ProxyIP is a TCP relay, not a TLS endpoint; forcing TLS here will break it.
   */
  const connectAndWritePlain = async (address, port) => {
    log(`Connecting (plain TCP) to proxy ${address}:${port}`);
    let tcpSocket;
    try {
      tcpSocket = connect({ hostname: address, port, allowHalfOpen: false });
    } catch (err) {
      throw new Error(`Plain connect failed for ${address}:${port} - ${err}`);
    }
    remoteSocketWrapper.value = tcpSocket;
    const writer = tcpSocket.writable.getWriter();
    try {
      await writer.write(rawClientData);
    } catch (err) {
      log("Error writing initial data to proxy TCP socket", err);
      throw err;
    } finally {
      writer.releaseLock();
    }
    return tcpSocket;
  };

  /**
   * Retry connection:
   *   1. PROXYIP is set (env/KV/auto-selected) â†’ plain TCP to that proxy.
   *   2. PROXYIP is empty (edge case â€” backupIP pool was empty) â†’ direct TLS
   *      to the original target as a last resort.
   *
   * If the first proxy attempt fails, cycle through the full backupIP pool
   * ordered by proximity to currentWorkerRegion before giving up.
   */
  const retry = async () => {
    // Build candidate list: configured proxyIP first, then full sorted pool
    const candidates = [];

    const parsed = parseProxyIP(proxyIP);
    if (parsed) {
      candidates.push({ host: parsed.host, port: parsed.port, isProxy: true, label: proxyIP });
    }

    // Add remaining backupIPs (skip the one already in proxyIP to avoid duplicate)
    const sortedBackups = getSortedBackupIPs(currentWorkerRegion);
    for (const b of sortedBackups) {
      const candidateStr = `${b.domain}:${b.port}`;
      if (candidateStr !== proxyIP) {
        candidates.push({ host: b.domain, port: b.port, isProxy: true, label: candidateStr });
      }
    }

    // If no proxy candidates at all, fall back to direct TLS (last resort)
    if (candidates.length === 0) {
      candidates.push({ host: addressRemote, port: portRemote, isProxy: false, label: `${addressRemote}:${portRemote} (direct)` });
    }

    for (const candidate of candidates) {
      log(`Retrying via ${candidate.isProxy ? "proxy" : "direct"} â†’ ${candidate.label}`);
      try {
        const tcpSocket = candidate.isProxy
          ? await connectAndWritePlain(candidate.host, candidate.port)
          : await connectAndWrite(candidate.host, candidate.port);

        tcpSocket.closed
          .catch((err) => log(`Retry TCP socket closed error for ${candidate.label}`, err))
          .finally(() => {
            try { if (typeof tcpSocket.close === "function") tcpSocket.close(); } catch {}
            safeCloseWebSocket(webSocket);
          });

        // Pass null â€” no further retry after this level
        remoteSocketToWS(tcpSocket, webSocket, null, log);
        return; // success â€” stop iterating candidates
      } catch (err) {
        log(`Candidate ${candidate.label} failed: ${err.message}`);
        // continue to next candidate
      }
    }

    // All candidates exhausted
    log(`All retry candidates exhausted for ${addressRemote}:${portRemote}`);
    safeCloseWebSocket(webSocket);
  };

  try {
    const tcpSocket = await connectAndWrite(addressRemote, portRemote);

    tcpSocket.closed
      .catch((err) => log(`TCP socket closed error for ${addressRemote}:${portRemote}`, err))
      .finally(() => {
        try { if (typeof tcpSocket.close === "function") tcpSocket.close(); } catch {}
        // Always close the WebSocket when the TCP side closes â€” same as Index.js
        safeCloseWebSocket(webSocket);
      });

    remoteSocketToWS(tcpSocket, webSocket, retry, log);
    
  } catch (err) {
    log(`TCP outbound connection failed for ${addressRemote}:${portRemote}`, err);
    await retry();
  }
}

//-----------------------------------------------------------------------------
// Pipe TCP â†’ WebSocket
//-----------------------------------------------------------------------------
/**
 * Pipes data from a TCP socket to a WebSocket with proper backpressure and cleanup.
 *
 * @param {any} remoteSocket - The TCP socket.
 * @param {WebSocket} webSocket - The WebSocket.
 * @param {(() => Promise<void>) | null} retry - Optional retry function on connection drop.
 * @param {(msg: string, err?: any) => void} log - Logging callback.
 */
async function remoteSocketToWS(remoteSocket, webSocket, retry, log) {
  const protocol = webSocket.protocol?.toLowerCase();
  const isLowLatency = protocol === "voip";
  let hasIncomingData = false;

  try {
    if (isLowLatency) {
      const reader = remoteSocket.readable.getReader();
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        hasIncomingData = true;
        if (webSocket.readyState === 1) {
          webSocket.send(value);
        } else {
          throw new Error("WebSocket not open");
        }
      }
    } else {
      
      await remoteSocket.readable.pipeTo(
        new WritableStream({
          async write(chunk) {
            hasIncomingData = true;
            if (webSocket.readyState !== 1) throw new Error("WebSocket not open");
            webSocket.send(chunk);
          },
          close() {
            log(`TCP stream closed; data received: ${hasIncomingData}`);
          },
          abort(reason) {
            console.error("TCP stream aborted:", reason);
          },
        })
      );
    }
    
  } catch (error) {
      
    console.error("remoteSocketToWS error:", error);

    safeCloseWebSocket(webSocket);
    if (retry) {
      log("Connection dropped. Attempting reconnect...");
      await retry();
    }
  }

  if (!hasIncomingData && retry && !isLowLatency) {
    log("No incoming data detected; retrying connection.");
    await retry();
  }
}

//-----------------------------------------------------------------------------
// Convert WebSocket messages to a ReadableStream (binary only) with earlyData
//-----------------------------------------------------------------------------
/**
 * Creates a readable stream from a WebSocket with improved state management.
 *
 * @param {WebSocket} webSocketServer - The WebSocket server instance.
 * @param {string} earlyDataHeader - Optional early data in base64 format.
 * @param {(msg: string, err?: any) => void} log - Logging callback.
 * @returns {ReadableStream<Uint8Array>}
 */
function makeReadableWebSocketStream(webSocketServer, earlyDataHeader, log) {
  let canceled = false;
  let controller;
  
  // Pre-create text encoder instance to avoid repeated instantiation
  const encoder = new TextEncoder();
  
  // Optimized message handler with reduced function calls
  const onMessage = (event) => {
    if (canceled) return;
    
    const data = event.data;
    const dataType = typeof data;
    
    if (dataType === "string") {
      controller.enqueue(encoder.encode(data));
    } else if (data instanceof Blob) {
      // Use more efficient blob handling with proper error handling
      data.arrayBuffer().then(
        buffer => !canceled && controller.enqueue(new Uint8Array(buffer)),
        err => !canceled && controller.error(new Error(`Blob conversion failed: ${err.message}`))
      );
    } else {
      // Assume it's already a buffer-like object
      controller.enqueue(data);
    }
  };
  
  // Centralized cleanup function to reduce code duplication
  const cleanup = () => {
    webSocketServer.removeEventListener("message", onMessage);
    webSocketServer.removeEventListener("close", onClose);
    webSocketServer.removeEventListener("error", onError);
  };
  
  const onClose = () => {
    cleanup();
    if (!canceled) {
      try {
        controller.close();
      } catch (e) {
        // Controller might already be closed, ignore error
      }
    }
  };
  
  const onError = (err) => {
    cleanup();
    if (!canceled) {
      controller.error(err);
    }
  };
  
  return new ReadableStream({
    start(ctrl) {
      controller = ctrl;
      
      // Add event listeners
      webSocketServer.addEventListener("message", onMessage);
      webSocketServer.addEventListener("close", onClose);
      webSocketServer.addEventListener("error", onError);
      
      // Handle early data more efficiently
      if (earlyDataHeader) {
        try {
          const { earlyData, error } = base64ToArrayBuffer(earlyDataHeader);
          if (error) {
            ctrl.error(error);
          } else if (earlyData && earlyData.length > 0) {
            ctrl.enqueue(earlyData);
          }
          
        } catch (err) {
          ctrl.error(new Error(`Early data processing failed: ${err.message}`));
        }
      }
    },
    
    cancel(reason) {
      if (canceled) return;
      canceled = true;
      
      // Use optional chaining for safer logging
      log?.(`Stream canceled: ${reason}`);
      
      cleanup();
      
      // Safe WebSocket closure with error handling
      try {
        safeCloseWebSocket(webSocketServer);
        
      } catch (err) {
        // Log error but don't throw to avoid masking the original cancellation reason
        log?.(`WebSocket close error: ${err.message}`);
      }
    },
  });
}


//-----------------------------------------------------------------------------
// WebSocket State Constants
//-----------------------------------------------------------------------------
/** WebSocket constants for comprehensive state checking. */
const WS_READY_STATE_CONNECTING = 0;
const WS_READY_STATE_OPEN = 1;
const WS_READY_STATE_CLOSING = 2;
const WS_READY_STATE_CLOSED = 3;

//-----------------------------------------------------------------------------
// Safe WebSocket Closure
//-----------------------------------------------------------------------------
/**
 * Safely closes a WebSocket connection with proper error handling and cleanup.
 * 
 * This function ensures graceful closure by:
 * - Validating the socket object exists and has the expected structure
 * - Checking if the socket is in a closeable state
 * - Providing comprehensive error logging
 * - Preventing multiple closure attempts
 *
 * @param {WebSocket | null | undefined} socket - The WebSocket instance to close
 * @param {number} [code=1000] - The close code (default: 1000 = normal closure)
 * @param {string} [reason=''] - Optional reason for closure
 * @returns {boolean} - Returns true if closure was attempted, false otherwise
 */
function safeCloseWebSocket(socket, code = 1000, reason = '') {
  try {
    // Validate socket exists and has readyState property
    if (!socket || typeof socket.readyState !== 'number') {
      console.warn('Invalid WebSocket provided to safeCloseWebSocket');
      return false;
    }

    // Only attempt to close if socket is open or closing
    if (socket.readyState === WS_READY_STATE_OPEN || socket.readyState === WS_READY_STATE_CLOSING) {
      socket.close(code, reason);
      console.debug(`WebSocket closed with code: ${code}, reason: ${reason || 'No reason provided'}`);
      return true;
    }

    // Log current state for debugging
    const stateNames = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
    console.debug(`WebSocket already in ${stateNames[socket.readyState]} state, no action needed`);
    return false;

  } catch (error) {
    console.error('Error during WebSocket closure:', {
      error: error.message,
      stack: error.stack,
      socketState: socket?.readyState ?? 'unknown'
    });
    return false;
  }
}

//-----------------------------------------------------------------------------
// Generate Trojan nodes for subscription import.
//
// KEY ARCHITECTURE POINT:
// The client ALWAYS connects to the Cloudflare worker (hostName). The proxyIP
// is used INTERNALLY by the worker to relay TCP onward â€” the client never
// connects to a proxyIP directly. Giving the client nodes pointing at backupIP
// domains causes SSL errors because those relays don't speak Trojan-over-WS.
//
// To give users multiple nodes we generate one node per Cloudflare CDN anycast
// IP with hostName as SNI/host â€” same approach Index.js uses with preferred IPs.
// Returns an array of trojan:// URI strings.
//-----------------------------------------------------------------------------
function generateTrojanNodes(pwd, hostName) {
  const echDomain = customECHDomain || 'cloudflare-ech.com';
  const dnsServer = customDNS || 'https://cloudflare-dns.com/dns-query';
  const echSuffix = `&alpn=h3%2Ch2%2Chttp%2F1.1&ech=${encodeURIComponent(`${echDomain}+${dnsServer}`)}`;
  const links = [];

  // Build a single trojan link â€” same format as Index.js generateTrojanLinksFromSource.
  // server=ip/hostname, but SNI+host always = worker domain so CF routes correctly.
  const makeLink = (server, label) => {
    const base = `trojan://${encodeURIComponent(pwd)}@${server}:443` +
      `?security=tls&sni=${hostName}&fp=chrome&type=ws&host=${hostName}&path=%2F%3Fed%3D2048`;
    return base + echSuffix + `#${encodeURIComponent(label)}`;
  };

  // 1. Primary â€” worker hostname direct
  links.push(makeLink(hostName, 'ðŸŒ ' + hostName));

  // 2. Cloudflare anycast IPs â€” SNI=hostName so CF routes to the correct worker
  const cfIPs = [
    { ip: '104.21.0.1',    label: 'CF-US-1' },
    { ip: '172.67.0.1',    label: 'CF-US-2' },
    { ip: '162.159.0.1',   label: 'CF-US-3' },
    { ip: '104.16.0.1',    label: 'CF-US-4' },
    { ip: '104.17.0.1',    label: 'CF-US-5' },
    { ip: '141.101.64.1',  label: 'CF-EU-1' },
    { ip: '108.162.192.1', label: 'CF-EU-2' },
    { ip: '190.93.240.1',  label: 'CF-AP-1' },
    { ip: '188.114.96.1',  label: 'CF-AP-2' },
  ];

  for (const { ip, label } of cfIPs) {
    links.push(makeLink(ip, 'âš¡ ' + label));
  }

  return links;
}

//-----------------------------------------------------------------------------
// Generate Clash YAML via the subscription converter service
//-----------------------------------------------------------------------------
async function generateClashConfig(nodes, request, pwd, hostName) {
  // Build the base64 sub URL pointing back to this worker
  const subUrl = new URL(request.url);
  subUrl.pathname = `/${pwd}/sub`;
  subUrl.search = '?target=base64';
  const encodedSubUrl = encodeURIComponent(subUrl.toString());
  const converterUrl = `${scu}?target=clash&url=${encodedSubUrl}&insert=false&config=${encodeURIComponent(remoteConfigUrl)}&emoji=true&list=false&xudp=false&udp=false&tfo=false&expand=true&scv=false&fdn=false&new_name=true`;

  const response = await fetch(converterUrl);
  if (!response.ok) throw new Error(`Converter returned ${response.status}`);

  let clashConfig = await response.text();

  // Inject ech-opts into every proxy node line
  const echDomain = customECHDomain || 'cloudflare-ech.com';
  clashConfig = clashConfig.split('\n').map(line => {
    if (/^\s*-\s*\{/.test(line) && line.includes('name:') && line.includes('server:')) {
      if (line.includes('ech-opts')) return line;
      const lastBrace = line.lastIndexOf('}');
      if (lastBrace > 0) {
        const before = line.substring(0, lastBrace).trim();
        const needsComma = !before.endsWith(',') && !before.endsWith('{');
        return line.substring(0, lastBrace) +
          (needsComma ? ', ' : ' ') +
          `ech-opts: {enable: true, query-server-name: ${echDomain}}` +
          line.substring(lastBrace);
      }
    }
    return line;
  }).join('\n');

  // Replace DNS nameserver with the configured DoH
  const dnsServer = customDNS || 'https://cloudflare-dns.com/dns-query';
  clashConfig = clashConfig.replace(
    /^(\s*nameserver:\s*\n)((?:\s*-\s*[^\n]+\n)*)/m,
    (_, header) => header + `    - ${dnsServer}\n`
  );

  return clashConfig;
}

//-----------------------------------------------------------------------------
// Serve the Trojan config page with V2Ray and Clash subscription links
//-----------------------------------------------------------------------------
function serveConfigPage(pwd, hostName) {
  const subBase = `https://${hostName}/${pwd}/sub`;
  const v2rayLink = subBase;                           // base64 â€” universal V2Ray import
  const clashLink = `${scu}?target=clash&url=${encodeURIComponent(subBase + '?target=base64')}&insert=false&config=${encodeURIComponent(remoteConfigUrl)}&emoji=true&list=false&xudp=false&udp=false&tfo=false&expand=true&scv=false&fdn=false&new_name=true`;
  const trojanLink = buildTrojanLink(pwd, hostName);

  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Trojan Config</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Syne:wght@700;800&display=swap');
  :root {
    --bg: #0a0a0f;
    --surface: #12121a;
    --border: #1e1e2e;
    --accent: #7c3aed;
    --accent2: #06b6d4;
    --text: #e2e8f0;
    --muted: #64748b;
    --success: #10b981;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 2rem;
    background-image:
      radial-gradient(ellipse 80% 50% at 20% 20%, rgba(124,58,237,0.08) 0%, transparent 60%),
      radial-gradient(ellipse 60% 40% at 80% 80%, rgba(6,182,212,0.06) 0%, transparent 60%);
  }
  .container { max-width: 720px; width: 100%; }
  .header { margin-bottom: 2.5rem; }
  .header h1 {
    font-family: 'Syne', sans-serif;
    font-size: 2rem;
    font-weight: 800;
    letter-spacing: -0.03em;
    background: linear-gradient(135deg, #7c3aed, #06b6d4);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 0.4rem;
  }
  .header p { color: var(--muted); font-size: 0.8rem; }
  .badge {
    display: inline-flex; align-items: center; gap: 0.4rem;
    background: rgba(16,185,129,0.1); border: 1px solid rgba(16,185,129,0.3);
    color: var(--success); padding: 0.25rem 0.75rem; border-radius: 999px;
    font-size: 0.7rem; font-weight: 600; margin-top: 0.75rem;
    letter-spacing: 0.05em; text-transform: uppercase;
  }
  .badge::before { content: 'â—'; font-size: 0.6rem; }
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 1rem;
    position: relative;
    overflow: hidden;
    transition: border-color 0.2s;
  }
  .card:hover { border-color: #2a2a3e; }
  .card::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 2px;
  }
  .card.trojan::before { background: linear-gradient(90deg, #7c3aed, transparent); }
  .card.v2ray::before  { background: linear-gradient(90deg, #06b6d4, transparent); }
  .card.clash::before  { background: linear-gradient(90deg, #f59e0b, transparent); }
  .card-label {
    font-size: 0.65rem; font-weight: 700; letter-spacing: 0.12em;
    text-transform: uppercase; margin-bottom: 0.75rem;
    display: flex; align-items: center; gap: 0.5rem;
  }
  .card.trojan .card-label { color: #7c3aed; }
  .card.v2ray  .card-label { color: #06b6d4; }
  .card.clash  .card-label { color: #f59e0b; }
  .link-row {
    display: flex; align-items: stretch; gap: 0.5rem;
  }
  .link-box {
    flex: 1;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.75rem 1rem;
    font-size: 0.72rem;
    color: var(--muted);
    word-break: break-all;
    line-height: 1.5;
    cursor: text;
    user-select: all;
    transition: border-color 0.2s, color 0.2s;
    min-height: 3rem;
    display: flex;
    align-items: center;
  }
  .link-box:focus-within,
  .link-box:hover { border-color: #2a2a3e; color: var(--text); }
  .copy-btn {
    background: rgba(124,58,237,0.15);
    border: 1px solid rgba(124,58,237,0.3);
    color: #7c3aed;
    border-radius: 8px;
    padding: 0 1rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    font-weight: 600;
    cursor: pointer;
    white-space: nowrap;
    transition: all 0.15s;
    letter-spacing: 0.05em;
  }
  .copy-btn:hover { background: rgba(124,58,237,0.25); border-color: #7c3aed; }
  .copy-btn.v { background: rgba(6,182,212,0.15); border-color: rgba(6,182,212,0.3); color: #06b6d4; }
  .copy-btn.v:hover { background: rgba(6,182,212,0.25); border-color: #06b6d4; }
  .copy-btn.c { background: rgba(245,158,11,0.15); border-color: rgba(245,158,11,0.3); color: #f59e0b; }
  .copy-btn.c:hover { background: rgba(245,158,11,0.25); border-color: #f59e0b; }
  .copy-btn.copied { color: var(--success) !important; border-color: var(--success) !important; }
  .hint {
    margin-top: 0.6rem;
    font-size: 0.65rem;
    color: var(--muted);
    line-height: 1.5;
  }
  .footer {
    margin-top: 2rem;
    text-align: center;
    font-size: 0.65rem;
    color: #2a2a3e;
  }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>Trojan Config</h1>
    <p>${hostName}</p>
    <div class="badge">ECH Enabled Â· ${currentWorkerRegion || 'Global'}</div>
  </div>

  <div class="card trojan">
    <div class="card-label">â¬¡ Trojan Link</div>
    <div class="link-row">
      <div class="link-box" id="trojan-box">${trojanLink}</div>
      <button class="copy-btn" onclick="copy('trojan-box', this)">COPY</button>
    </div>
    <div class="hint">Single node â€” import directly into any Trojan/V2RayN/Clash client.</div>
  </div>

  <div class="card v2ray">
    <div class="card-label">â¬¡ V2Ray Subscription</div>
    <div class="link-row">
      <div class="link-box" id="v2ray-box">${v2rayLink}</div>
      <button class="copy-btn v" onclick="copy('v2ray-box', this)">COPY</button>
    </div>
    <div class="hint">Base64 sub â€” 10 nodes (worker hostname + 9 CF anycast IPs, all with ECH). Import into V2RayN, Shadowrocket, Nekoray, etc.</div>
  </div>

  <div class="card clash">
    <div class="card-label">â¬¡ Clash Subscription</div>
    <div class="link-row">
      <div class="link-box" id="clash-box">${clashLink}</div>
      <button class="copy-btn c" onclick="copy('clash-box', this)">COPY</button>
    </div>
    <div class="hint">Clash YAML via url.v1.mk converter Â· ECH injected Â· rule config from byJoey/test.</div>
  </div>

  <div class="footer">trojan-worker Â· ECH on Â· ${backupIPs.length} relay pool</div>
</div>
<script>
function copy(id, btn) {
  const text = document.getElementById(id).textContent.trim();
  navigator.clipboard.writeText(text).then(() => {
    const orig = btn.textContent;
    btn.textContent = 'COPIED';
    btn.classList.add('copied');
    setTimeout(() => { btn.textContent = orig; btn.classList.remove('copied'); }, 1800);
  });
}
</script>
</body>
</html>`;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/**
 * Builds a Trojan WebSocket link string. When ECH is enabled, adds
 * ECH parameters and sets fingerprint to 'chrome' (required for ECH).
 *
 * @param {string} pwd - The Trojan password.
 * @param {string} hostName - The worker hostname.
 * @returns {string} The Trojan URI.
 */
function buildTrojanLink(pwd, hostName) {
  const echDomain = customECHDomain || 'cloudflare-ech.com';
  const dnsServer = customDNS || 'https://cloudflare-dns.com/dns-query';

  // Base params â€” matches Index.js generateTrojanLinksFromSource format exactly.
  // path=/?ed=2048 enables WS early-data (0-RTT). No allowInsecure or earlyDataSize.
  let link = `trojan://${encodeURIComponent(pwd)}@${hostName}:443` +
    `?security=tls&sni=${hostName}&fp=chrome&type=ws&host=${hostName}&path=%2F%3Fed%3D2048`;

  // alpn + ech appended the same way Index.js does it
  link += `&alpn=h3%2Ch2%2Chttp%2F1.1&ech=${encodeURIComponent(`${echDomain}+${dnsServer}`)}`;

  link += `#${encodeURIComponent(hostName)}`;

  return link;
}

//-----------------------------------------------------------------------------
/**
 * Converts a base64-encoded string to an ArrayBuffer.
 * Supports both standard and URL-safe base64 encoding formats.
 *
 * @param {string} base64Str - The base64 string to convert.
 * @returns {{earlyData?: ArrayBuffer, error: Error | null}}
 */
function base64ToArrayBuffer(base64Str) {
  if (!base64Str || typeof base64Str !== 'string') {
    return { earlyData: undefined, error: null };
  }

  try {
    // Convert URL-safe base64 to standard base64
    let normalizedBase64 = base64Str.replace(/-/g, '+').replace(/_/g, '/');
    
    // Add padding if necessary
    const padding = normalizedBase64.length % 4;
    if (padding) {
      normalizedBase64 += '='.repeat(4 - padding);
    }
    
    // Decode base64 string
    const binaryString = atob(normalizedBase64);
    const length = binaryString.length;
    
    // Create Uint8Array more efficiently
    const uint8Array = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
      uint8Array[i] = binaryString.charCodeAt(i);
    }
    
    return { earlyData: uint8Array.buffer, error: null };
    
  } catch (error) {
    // Create a more descriptive error
    const enhancedError = new Error(`Failed to convert base64 to ArrayBuffer: ${error.message}`);
    enhancedError.originalError = error;
    return { earlyData: undefined, error: enhancedError };
  }
}

//-----------------------------------------------------------------------------
// HTTP(S) Homepage Endpoint
//-----------------------------------------------------------------------------
/**
 * Serves the homepage with additional security headers.
 * @param {any} env - The deployment environment for obtaining CACHE_CONTROL.
 * @returns {Response} The response containing the homepage HTML.
 */
function serveHomepage(env) {
  const headers = new Headers({
    "Content-Type": "text/html;charset=utf-8",
    Connection: "keep-alive",
    "Cache-Control": env.CACHE_CONTROL || "public",
    "X-Content-Type-Options": "nosniff",
    "X-Frame-Options": "DENY",
    "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
  });

  return new Response(cachedHomepageHTML, { status: 200, headers });
}

/**
 * Returns the Cloudflare homepage HTML.
 */

const cachedHomepageHTML = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Cloudflare! â›…ï¸</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        :root {
            --primary: #F38020;
            --background: #000;
            --text: #fff;
            --card-bg: rgba(255, 255, 255, 0.08);
            --border-color: rgba(255, 255, 255, 0.15);
            --gradient: linear-gradient(135deg, #F38020, #FFA927);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: var(--background);
            color: var(--text);
            font-family: 'Inter', sans-serif;
            padding: 2rem;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
        }
        
        .container {
            max-width: 650px;
            width: 100%;
            text-align: center;
            padding: 3rem;
            background: var(--card-bg);
            border-radius: 20px;
            border: 1px solid var(--border-color);
            backdrop-filter: blur(15px);
            box-shadow: 0 15px 40px rgba(255, 255, 255, 0.08);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .container:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 50px rgba(255, 255, 255, 0.15);
        }
        
        .logo {
            width: 100px;
            margin-bottom: 2rem;
        }
        
        .imgur-image {
            width: 100%;
            height: auto;
            border-radius: 10px;
            margin-bottom: 2rem;
            display: block;
            object-fit: contain;
        }
        
        h1 {
            font-size: 2.4rem;
            margin-bottom: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
        }
        
        p {
            font-size: 1.2rem;
            opacity: 0.85;
            margin-bottom: 1.8rem;
        }
        
        .message {
            font-size: 1rem;
            opacity: 0.7;
            margin-bottom: 2rem;
        }
        
        .links {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 2rem;
        }
        
        .link-card {
            padding: 1rem 1.5rem;
            border-radius: 14px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            backdrop-filter: blur(8px);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .link-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 255, 255, 0.15);
        }
        
        a {
            display: block;
            font-size: 1rem;
            font-weight: 600;
            color: var(--primary);
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        a:hover {
            color: #FFA927;
        }
        
        em {
            display: block;
            margin-top: 2rem;
            font-size: 0.9rem;
            opacity: 0.65;
        }
        
        @media (max-width: 640px) {
            .container {
                padding: 2rem;
            }
            h1 {
                font-size: 2rem;
            }
            .links {
                flex-direction: column;
                gap: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Cloudflare_Logo.svg/512px-Cloudflare_Logo.svg.png" alt="Cloudflare Logo" class="logo">
        <h1>Welcome to Cloudflare!</h1>
        <p>Your Cloudflare services are successfully configured and operational.</p>
        <img src="https://i.imgur.com/4XvzrJJ.jpg" alt="Cloudflare Network" class="imgur-image">
        <p class="message">A faster, safer, and more reliable internet powered by Cloudflare.</p>
        <div class="links">
            <div class="link-card">
                <a href="https://developers.cloudflare.com/">Docs â†’</a>
            </div>
            <div class="link-card">
                <a href="https://community.cloudflare.com/">Community â†’</a>
            </div>
        </div>
        <em>Cloudflare's global edge network</em>
    </div>
</body>
</html>
`;

//-----------------------------------------------------------------------------
// SHA-256
//-----------------------------------------------------------------------------
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.11.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2024
 * @license MIT
 */
(function () 
{
  "use strict";

  var ERROR = "input is invalid type";
  var WINDOW = typeof window === "object";
  var root = WINDOW ? window : {};
  if (root.JS_SHA256_NO_WINDOW) {
    WINDOW = false;
  }
  
  var WEB_WORKER = !WINDOW && typeof self === "object";
  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  
  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
  var AMD = typeof define === "function" && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
  var HEX_CHARS = "0123456789abcdef".split("");
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98,
    0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8,
    0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7,
    0xc67178f2,
  ];
  
  var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];

  var blocks = [];

  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) 
  {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (outputType, is224) 
  {
    return function (message) {
      return new Sha256(is224, true).update(message)[outputType]();
    };
  };

  var createMethod = function (is224) 
  {
    var method = createOutputMethod("hex", is224);
    if (NODE_JS) {
      method = nodeWrap(method, is224);
    }
    method.create = function () {
      return new Sha256(is224);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type, is224);
    }
    return method;
  };

  var nodeWrap = function (method, is224) 
  {
    var crypto = require("crypto");
    var Buffer = require("buffer").Buffer;
    var algorithm = is224 ? "sha224" : "sha256";
    var bufferFrom;
    if (Buffer.from && !root.JS_SHA256_NO_BUFFER_FROM) {
      bufferFrom = Buffer.from;
    } else {
      bufferFrom = function (message) {
        return new Buffer(message);
      };
    }
    
    var nodeMethod = function (message) {
      if (typeof message === "string") {
        return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
      } else {
        if (message === null || message === undefined) {
          throw new Error(ERROR);
        } else if (message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        }
      }
      
      if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
        return crypto.createHash(algorithm).update(bufferFrom(message)).digest("hex");
      } else {
        return method(message);
      }
    };
    return nodeMethod;
  };

  var createHmacOutputMethod = function (outputType, is224) 
  {
    return function (key, message) {
      return new HmacSha256(key, is224, true).update(message)[outputType]();
    };
  };

  var createHmacMethod = function (is224) 
  {
    var method = createHmacOutputMethod("hex", is224);
    method.create = function (key) {
      return new HmacSha256(key, is224);
    };
    method.update = function (key, message) {
      return method.create(key).update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createHmacOutputMethod(type, is224);
    }
    return method;
  };

  function Sha256(is224, sharedMemory) 
  {
    if (sharedMemory) {
      blocks[0] =
        blocks[16] =
        blocks[1] =
        blocks[2] =
        blocks[3] =
        blocks[4] =
        blocks[5] =
        blocks[6] =
        blocks[7] =
        blocks[8] =
        blocks[9] =
        blocks[10] =
        blocks[11] =
        blocks[12] =
        blocks[13] =
        blocks[14] =
        blocks[15] =
          0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    if (is224) 
    {
      this.h0 = 0xc1059ed8;
      this.h1 = 0x367cd507;
      this.h2 = 0x3070dd17;
      this.h3 = 0xf70e5939;
      this.h4 = 0xffc00b31;
      this.h5 = 0x68581511;
      this.h6 = 0x64f98fa7;
      this.h7 = 0xbefa4fa4;
    } else {
      // 256
      this.h0 = 0x6a09e667;
      this.h1 = 0xbb67ae85;
      this.h2 = 0x3c6ef372;
      this.h3 = 0xa54ff53a;
      this.h4 = 0x510e527f;
      this.h5 = 0x9b05688c;
      this.h6 = 0x1f83d9ab;
      this.h7 = 0x5be0cd19;
    }

    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
    this.is224 = is224;
  }

  Sha256.prototype.update = function (message) 
  {
    if (this.finalized) {
      return;
    }
    
    var notString,
      type = typeof message;
    if (type !== "string") {
      if (type === "object") {
        if (message === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
      notString = true;
    }
    
    var code,
      index = 0,
      i,
      length = message.length,
      blocks = this.blocks;
    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = this.block;
        this.block =
          blocks[16] =
          blocks[1] =
          blocks[2] =
          blocks[3] =
          blocks[4] =
          blocks[5] =
          blocks[6] =
          blocks[7] =
          blocks[8] =
          blocks[9] =
          blocks[10] =
          blocks[11] =
          blocks[12] =
          blocks[13] =
          blocks[14] =
          blocks[15] =
            0;
      }

      if (notString) {
        for (i = this.start; index < length && i < 64; ++index) {
          blocks[i >>> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } 
      
      else 
      {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >>> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >>> 2] |= (0xc0 | (code >>> 6)) << SHIFT[i++ & 3];
            blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >>> 2] |= (0xe0 | (code >>> 12)) << SHIFT[i++ & 3];
            blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >>> 2] |= (0xf0 | (code >>> 18)) << SHIFT[i++ & 3];
            blocks[i >>> 2] |= (0x80 | ((code >>> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }

      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.block = blocks[16];
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    
    if (this.bytes > 4294967295) {
      this.hBytes += (this.bytes / 4294967296) << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };

  Sha256.prototype.finalize = function () 
  {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks,
      i = this.lastByteIndex;
    blocks[16] = this.block;
    blocks[i >>> 2] |= EXTRA[i & 3];
    this.block = blocks[16];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = this.block;
      blocks[16] =
        blocks[1] =
        blocks[2] =
        blocks[3] =
        blocks[4] =
        blocks[5] =
        blocks[6] =
        blocks[7] =
        blocks[8] =
        blocks[9] =
        blocks[10] =
        blocks[11] =
        blocks[12] =
        blocks[13] =
        blocks[14] =
        blocks[15] =
          0;
    }
    blocks[14] = (this.hBytes << 3) | (this.bytes >>> 29);
    blocks[15] = this.bytes << 3;
    this.hash();
  };

  Sha256.prototype.hash = function () 
  {
    var a = this.h0,
      b = this.h1,
      c = this.h2,
      d = this.h3,
      e = this.h4,
      f = this.h5,
      g = this.h6,
      h = this.h7,
      blocks = this.blocks,
      j,
      s0,
      s1,
      maj,
      t1,
      t2,
      ch,
      ab,
      da,
      cd,
      bc;

    for (j = 16; j < 64; ++j) {
      t1 = blocks[j - 15];
      s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
      t1 = blocks[j - 2];
      s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
      blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;
    }

    bc = b & c;
    for (j = 0; j < 64; j += 4) {
      if (this.first) {
        if (this.is224) {
          ab = 300032;
          t1 = blocks[0] - 1413257819;
          h = (t1 - 150054599) << 0;
          d = (t1 + 24177077) << 0;
        } else {
          ab = 704751109;
          t1 = blocks[0] - 210244248;
          h = (t1 - 1521486534) << 0;
          d = (t1 + 143694565) << 0;
        }
        this.first = false;
      } else {
        s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
        s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
        ab = a & b;
        maj = ab ^ (a & c) ^ bc;
        ch = (e & f) ^ (~e & g);
        t1 = h + s1 + ch + K[j] + blocks[j];
        t2 = s0 + maj;
        h = (d + t1) << 0;
        d = (t1 + t2) << 0;
      }
      s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));
      s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));
      da = d & a;
      maj = da ^ (d & b) ^ ab;
      ch = (h & e) ^ (~h & f);
      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
      t2 = s0 + maj;
      g = (c + t1) << 0;
      c = (t1 + t2) << 0;
      s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));
      s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));
      cd = c & d;
      maj = cd ^ (c & a) ^ da;
      ch = (g & h) ^ (~g & e);
      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
      t2 = s0 + maj;
      f = (b + t1) << 0;
      b = (t1 + t2) << 0;
      s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));
      s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));
      bc = b & c;
      maj = bc ^ (b & d) ^ cd;
      ch = (f & g) ^ (~f & h);
      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
      t2 = s0 + maj;
      e = (a + t1) << 0;
      a = (t1 + t2) << 0;
      this.chromeBugWorkAround = true;
    }

    this.h0 = (this.h0 + a) << 0;
    this.h1 = (this.h1 + b) << 0;
    this.h2 = (this.h2 + c) << 0;
    this.h3 = (this.h3 + d) << 0;
    this.h4 = (this.h4 + e) << 0;
    this.h5 = (this.h5 + f) << 0;
    this.h6 = (this.h6 + g) << 0;
    this.h7 = (this.h7 + h) << 0;
  };

  Sha256.prototype.hex = function () 
  {
    this.finalize();

    var h0 = this.h0,
      h1 = this.h1,
      h2 = this.h2,
      h3 = this.h3,
      h4 = this.h4,
      h5 = this.h5,
      h6 = this.h6,
      h7 = this.h7;

    var hex =
      HEX_CHARS[(h0 >>> 28) & 0x0f] +
      HEX_CHARS[(h0 >>> 24) & 0x0f] +
      HEX_CHARS[(h0 >>> 20) & 0x0f] +
      HEX_CHARS[(h0 >>> 16) & 0x0f] +
      HEX_CHARS[(h0 >>> 12) & 0x0f] +
      HEX_CHARS[(h0 >>> 8) & 0x0f] +
      HEX_CHARS[(h0 >>> 4) & 0x0f] +
      HEX_CHARS[h0 & 0x0f] +
      HEX_CHARS[(h1 >>> 28) & 0x0f] +
      HEX_CHARS[(h1 >>> 24) & 0x0f] +
      HEX_CHARS[(h1 >>> 20) & 0x0f] +
      HEX_CHARS[(h1 >>> 16) & 0x0f] +
      HEX_CHARS[(h1 >>> 12) & 0x0f] +
      HEX_CHARS[(h1 >>> 8) & 0x0f] +
      HEX_CHARS[(h1 >>> 4) & 0x0f] +
      HEX_CHARS[h1 & 0x0f] +
      HEX_CHARS[(h2 >>> 28) & 0x0f] +
      HEX_CHARS[(h2 >>> 24) & 0x0f] +
      HEX_CHARS[(h2 >>> 20) & 0x0f] +
      HEX_CHARS[(h2 >>> 16) & 0x0f] +
      HEX_CHARS[(h2 >>> 12) & 0x0f] +
      HEX_CHARS[(h2 >>> 8) & 0x0f] +
      HEX_CHARS[(h2 >>> 4) & 0x0f] +
      HEX_CHARS[h2 & 0x0f] +
      HEX_CHARS[(h3 >>> 28) & 0x0f] +
      HEX_CHARS[(h3 >>> 24) & 0x0f] +
      HEX_CHARS[(h3 >>> 20) & 0x0f] +
      HEX_CHARS[(h3 >>> 16) & 0x0f] +
      HEX_CHARS[(h3 >>> 12) & 0x0f] +
      HEX_CHARS[(h3 >>> 8) & 0x0f] +
      HEX_CHARS[(h3 >>> 4) & 0x0f] +
      HEX_CHARS[h3 & 0x0f] +
      HEX_CHARS[(h4 >>> 28) & 0x0f] +
      HEX_CHARS[(h4 >>> 24) & 0x0f] +
      HEX_CHARS[(h4 >>> 20) & 0x0f] +
      HEX_CHARS[(h4 >>> 16) & 0x0f] +
      HEX_CHARS[(h4 >>> 12) & 0x0f] +
      HEX_CHARS[(h4 >>> 8) & 0x0f] +
      HEX_CHARS[(h4 >>> 4) & 0x0f] +
      HEX_CHARS[h4 & 0x0f] +
      HEX_CHARS[(h5 >>> 28) & 0x0f] +
      HEX_CHARS[(h5 >>> 24) & 0x0f] +
      HEX_CHARS[(h5 >>> 20) & 0x0f] +
      HEX_CHARS[(h5 >>> 16) & 0x0f] +
      HEX_CHARS[(h5 >>> 12) & 0x0f] +
      HEX_CHARS[(h5 >>> 8) & 0x0f] +
      HEX_CHARS[(h5 >>> 4) & 0x0f] +
      HEX_CHARS[h5 & 0x0f] +
      HEX_CHARS[(h6 >>> 28) & 0x0f] +
      HEX_CHARS[(h6 >>> 24) & 0x0f] +
      HEX_CHARS[(h6 >>> 20) & 0x0f] +
      HEX_CHARS[(h6 >>> 16) & 0x0f] +
      HEX_CHARS[(h6 >>> 12) & 0x0f] +
      HEX_CHARS[(h6 >>> 8) & 0x0f] +
      HEX_CHARS[(h6 >>> 4) & 0x0f] +
      HEX_CHARS[h6 & 0x0f];
    if (!this.is224) {
      hex +=
        HEX_CHARS[(h7 >>> 28) & 0x0f] +
        HEX_CHARS[(h7 >>> 24) & 0x0f] +
        HEX_CHARS[(h7 >>> 20) & 0x0f] +
        HEX_CHARS[(h7 >>> 16) & 0x0f] +
        HEX_CHARS[(h7 >>> 12) & 0x0f] +
        HEX_CHARS[(h7 >>> 8) & 0x0f] +
        HEX_CHARS[(h7 >>> 4) & 0x0f] +
        HEX_CHARS[h7 & 0x0f];
    }
    return hex;
  };

  Sha256.prototype.toString = Sha256.prototype.hex;

  Sha256.prototype.digest = function () 
  {
    this.finalize();

    var h0 = this.h0,
      h1 = this.h1,
      h2 = this.h2,
      h3 = this.h3,
      h4 = this.h4,
      h5 = this.h5,
      h6 = this.h6,
      h7 = this.h7;

    var arr = [
      (h0 >>> 24) & 0xff,
      (h0 >>> 16) & 0xff,
      (h0 >>> 8) & 0xff,
      h0 & 0xff,
      (h1 >>> 24) & 0xff,
      (h1 >>> 16) & 0xff,
      (h1 >>> 8) & 0xff,
      h1 & 0xff,
      (h2 >>> 24) & 0xff,
      (h2 >>> 16) & 0xff,
      (h2 >>> 8) & 0xff,
      h2 & 0xff,
      (h3 >>> 24) & 0xff,
      (h3 >>> 16) & 0xff,
      (h3 >>> 8) & 0xff,
      h3 & 0xff,
      (h4 >>> 24) & 0xff,
      (h4 >>> 16) & 0xff,
      (h4 >>> 8) & 0xff,
      h4 & 0xff,
      (h5 >>> 24) & 0xff,
      (h5 >>> 16) & 0xff,
      (h5 >>> 8) & 0xff,
      h5 & 0xff,
      (h6 >>> 24) & 0xff,
      (h6 >>> 16) & 0xff,
      (h6 >>> 8) & 0xff,
      h6 & 0xff,
    ];
    
    if (!this.is224) {
      arr.push((h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, h7 & 0xff);
    }
    return arr;
  };

  Sha256.prototype.array = Sha256.prototype.digest;

  Sha256.prototype.arrayBuffer = function () 
  {
    this.finalize();

    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0);
    dataView.setUint32(4, this.h1);
    dataView.setUint32(8, this.h2);
    dataView.setUint32(12, this.h3);
    dataView.setUint32(16, this.h4);
    dataView.setUint32(20, this.h5);
    dataView.setUint32(24, this.h6);
    if (!this.is224) {
      dataView.setUint32(28, this.h7);
    }
    return buffer;
  };

  function HmacSha256(key, is224, sharedMemory) 
  {
    var i,
      type = typeof key;
    if (type === "string") {
      var bytes = [],
        length = key.length,
        index = 0,
        code;
      for (i = 0; i < length; ++i) {
        code = key.charCodeAt(i);
        if (code < 0x80) {
          bytes[index++] = code;
        } 
        else if (code < 0x800) {
          bytes[index++] = 0xc0 | (code >>> 6);
          bytes[index++] = 0x80 | (code & 0x3f);
        } 
        else if (code < 0xd800 || code >= 0xe000) {
          bytes[index++] = 0xe0 | (code >>> 12);
          bytes[index++] = 0x80 | ((code >>> 6) & 0x3f);
          bytes[index++] = 0x80 | (code & 0x3f);
        } 
        else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));
          bytes[index++] = 0xf0 | (code >>> 18);
          bytes[index++] = 0x80 | ((code >>> 12) & 0x3f);
          bytes[index++] = 0x80 | ((code >>> 6) & 0x3f);
          bytes[index++] = 0x80 | (code & 0x3f);
        }
      }
      key = bytes;
    } 
    
    else 
    {
      if (type === "object") {
        if (key === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
          key = new Uint8Array(key);
        } else if (!Array.isArray(key)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
    }

    if (key.length > 64) {
      key = new Sha256(is224, true).update(key).array();
    }

    var oKeyPad = [],
      iKeyPad = [];
    for (i = 0; i < 64; ++i) {
      var b = key[i] || 0;
      oKeyPad[i] = 0x5c ^ b;
      iKeyPad[i] = 0x36 ^ b;
    }

    Sha256.call(this, is224, sharedMemory);

    this.update(iKeyPad);
    this.oKeyPad = oKeyPad;
    this.inner = true;
    this.sharedMemory = sharedMemory;
  }
  HmacSha256.prototype = new Sha256();

  HmacSha256.prototype.finalize = function () 
  {
    Sha256.prototype.finalize.call(this);
    if (this.inner) {
      this.inner = false;
      var innerHash = this.array();
      Sha256.call(this, this.is224, this.sharedMemory);
      this.update(this.oKeyPad);
      this.update(innerHash);
      Sha256.prototype.finalize.call(this);
    }
  };

  var exports = createMethod();
  exports.sha256 = exports;
  exports.sha224 = createMethod(true);
  exports.sha256.hmac = createHmacMethod();
  exports.sha224.hmac = createHmacMethod(true);

  if (COMMON_JS) 
  {
    module.exports = exports;
  } else {
    root.sha256 = exports.sha256;
    root.sha224 = exports.sha224;
    if (AMD) {
      define(function () {
        return exports;
      });
    }
  }
})();
