//-----------------------------------------------------------------------------
// A Cloudflare Worker/Pages-based Trojan Proxy
// ProxyIP and WebSocket Transport
// By Dr. Upendra
//-----------------------------------------------------------------------------
import { connect } from "cloudflare:sockets";

// Global reusable encoder/decoder.
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();

// Environment variables.
let password = ""; // MUST be provided explicitly from Environment
let sha224Password;

// Connection parameter.
let proxyIP = ""; // MUST be provided explicitly from Environment

// Keepalive parameter.
let keepaliveMs = 0; // optional, read from env

//-----------------------------------------------------------------------------
// Main Worker Fetch Handler
//-----------------------------------------------------------------------------
export default {
  async fetch(request, env, ctx) {
    try {
      // Init globals once per invocation
      password = env.PASSWORD || env.pswd || env.UUID || env.uuid || env.TOKEN;
      if (!password) {
        throw new Error("Missing required PASSWORD/UUID/TOKEN environment variable.");
      }

      sha224Password = env.SHA224 || env.SHA224PASS || sha224(password);
      keepaliveMs = Number(env.KEEPALIVE_MS) || 0;
      proxyIP = env.PROXYIP || env.proxyip || "";

      if (proxyIP && !/^(?:[a-zA-Z0-9.-]+|\[[a-fA-F0-9:]+\]):\d+$/.test(proxyIP)) {
        console.warn(`Invalid PROXYIP format: "${proxyIP}" — clearing.`);
        proxyIP = "";
      }

      const reqUrl = new URL(request.url);

      // Homepage
      if (reqUrl.pathname === "/") {
        return serveHomepage(env);
      }

      // Config page: /<password>
      // Returns styled HTML with trojan link + V2Ray sub link + Clash sub link
      if (reqUrl.pathname === `/${password}`) {
        const hostName = request.headers.get("Host") || "example.com";
        return new Response(serveConfigPage(password, hostName), {
          status: 200,
          headers: { "Content-Type": "text/html;charset=utf-8" },
        });
      }

      // Subscription: /<password>/sub
      // default → base64 nodes (V2Ray/universal import)
      // ?target=clash → Clash YAML
      if (reqUrl.pathname === `/${password}/sub`) {
        const hostName = request.headers.get("Host") || "example.com";
        const target = (reqUrl.searchParams.get("target") || "").toLowerCase();
        const nodes = generateTrojanNodes(password, hostName);
        const base64Content = btoa(nodes.join("\n"));

        if (target === "clash") {
          try {
            const clashYaml = await generateClashConfig(nodes, request, password, hostName);
            return new Response(clashYaml, {
              status: 200,
              headers: { "Content-Type": "text/yaml;charset=utf-8", "Cache-Control": "no-store" },
            });
          } catch (err) {
            return new Response(`# Clash config generation failed: ${err.message}`, {
              status: 502,
              headers: { "Content-Type": "text/yaml;charset=utf-8" },
            });
          }
        }

        return new Response(base64Content, {
          status: 200,
          headers: { "Content-Type": "text/plain;charset=utf-8", "Cache-Control": "no-store" },
        });
      }

      // WebSocket upgrade validation
      const upgradeHeader = request.headers.get("Upgrade");
      const websocketKey  = request.headers.get("sec-websocket-key");
      const allowedProtocols = ["ws", "wss", "voip"];
      const subprotocol = request.headers.get("sec-websocket-protocol") || "";

      if (!upgradeHeader || upgradeHeader.toLowerCase() !== "websocket" || !websocketKey) {
        return new Response(
          "WebSocket connections only. Visit /<your-password> for config.",
          { status: 400, headers: { "Content-Type": "text/plain;charset=utf-8" } }
        );
      }

      if (subprotocol && !allowedProtocols.includes(subprotocol.toLowerCase())) {
        return new Response("Unsupported WebSocket subprotocol.", { status: 400 });
      }

      // Handle Trojan-over-WebSocket
      const trojanPromise = handleTrojanOverWS(request);
      ctx.waitUntil(trojanPromise);
      return await trojanPromise;

    } catch (err) {
      console.error("Global fetch error:", err);
      return new Response(err.toString(), { status: 500 });
    }
  },
};

//-----------------------------------------------------------------------------
// Handle Trojan-over-WebSocket Connections
//-----------------------------------------------------------------------------
async function handleTrojanOverWS(request) {
  const webSocketPair = new WebSocketPair();
  const [client, webSocket] = Object.values(webSocketPair);

  try {
    webSocket.accept();
    webSocket.binaryType = "arraybuffer";
  } catch (error) {
    console.error("WebSocket handshake failure:", error);
    return new Response("WebSocket handshake error", { status: 400 });
  }

  let address = "";
  let portWithRandomLog = "";
  const logId = Math.random().toFixed(4);

  const log = (info, event) => {
    console.log(`[${new Date().toISOString()}] [${address}:${portWithRandomLog}] ${info}`, event || "");
  };

  let keepaliveTimer = null;
  let isActive = true;

  const startKeepalive = () => {
    if (Number.isFinite(keepaliveMs) && keepaliveMs > 0 && isActive) {
      keepaliveTimer = setInterval(() => {
        if (!isActive) { clearInterval(keepaliveTimer); return; }
        try {
          if (webSocket?.readyState === 1) {
            webSocket.send("~keepalive~");
          } else {
            clearInterval(keepaliveTimer);
            keepaliveTimer = null;
          }
        } catch (e) {
          console.error("Keepalive send error:", e);
          clearInterval(keepaliveTimer);
          keepaliveTimer = null;
        }
      }, keepaliveMs);
    }
  };

  const stopKeepalive = () => {
    isActive = false;
    if (keepaliveTimer) { clearInterval(keepaliveTimer); keepaliveTimer = null; }
  };

  webSocket.addEventListener("close", (evt) => {
    log(`websocket closed (code=${evt.code} reason=${evt.reason})`);
    stopKeepalive();
  }, { once: true });

  webSocket.addEventListener("error", (evt) => {
    log("websocket error", evt);
    stopKeepalive();
  });

  startKeepalive();

  const earlyDataHeader = request.headers.get("sec-websocket-protocol") || "";
  const readableWebSocketStream = makeReadableWebSocketStream(webSocket, earlyDataHeader, log);
  const remoteSocketWrapper = { value: null };

  const processStream = async () => {
    const reader = readableWebSocketStream.getReader();
    let headerParsed = false;

    try {
      while (isActive) {
        const result = await reader.read();
        if (result.done) break;
        const { value } = result;

        if (headerParsed && remoteSocketWrapper.value) {
          try {
            const writer = remoteSocketWrapper.value.writable.getWriter();
            await writer.write(value);
            writer.releaseLock();
          } catch (err) {
            log("Error writing to TCP socket", err);
            break;
          }
          continue;
        }

        if (!headerParsed) {
          try {
            const {
              hasError, message,
              portRemote = 443,
              addressRemote = "",
              rawClientData,
              passwordFromClient,
            } = await parseTrojanHeader(value);

            address = addressRemote;
            portWithRandomLog = `${portRemote}--${logId}`;

            if (hasError) throw new Error(`Header parse error: ${message}`);
            if (!isValidPassword(passwordFromClient)) throw new Error("invalid password");
            if (!addressRemote) throw new Error(`Invalid address for port ${portRemote}`);

            log(`Processing TCP outbound ${addressRemote}:${portRemote}`);
            headerParsed = true;
            handleTCPOutbound(remoteSocketWrapper, addressRemote, portRemote, rawClientData, webSocket, log);

          } catch (err) {
            log("Header parsing error", err);
            throw err;
          }
        }
      }
    } catch (err) {
      log("Error processing WebSocket stream", err);
      throw err;
    } finally {
      try { reader.releaseLock(); } catch {}
      stopKeepalive();
      safeCloseWebSocket(webSocket);
    }
  };

  processStream().catch(err => {
    console.error("Stream processing failed:", err);
    stopKeepalive();
    safeCloseWebSocket(webSocket);
  });

  return new Response(null, { status: 101, webSocket: client });
}


function isValidPassword(clientPwd) {
  if (!clientPwd) return false;
  try {
    if (constantTimeEqual(clientPwd, password)) return true;
    if (constantTimeEqual(clientPwd.toLowerCase(), sha224(password).toLowerCase())) return true;
  } catch {}
  return false;
}

//-----------------------------------------------------------------------------
// Trojan Header Parsing (variable-length password + CRLF, proper SOCKS layout)
//-----------------------------------------------------------------------------
/**
 * Trojan spec (classic/GFW):
 *   <PASSWORD><CRLF><CMD=0x01><ATYP><DST-ADDR><DST-PORT(2)><CRLF><DATA...>
 * ATYP: 0x01=IPv4 (4 bytes), 0x03=DOMAIN (1 len + name), 0x04=IPv6 (16 bytes)
 *
 * @param {ArrayBuffer} buffer
 * @returns {Promise<{hasError: boolean, message?: string, addressRemote?: string, portRemote?: number, rawClientData?: ArrayBuffer, passwordFromClient?: string}>}
 */
async function parseTrojanHeader(buffer) {
  if (!(buffer instanceof ArrayBuffer) || buffer.byteLength < 4) {
    return { hasError: true, message: "insufficient data" };
  }

  // 1) Extract password up to CRLF
  const { passwordFromClient, rest, error } = extractPasswordAndRest(buffer);
  if (error) return { hasError: true, message: error };

  // 2) Parse command + address
  const bytes = new Uint8Array(rest);
  if (bytes.length < 4) return { hasError: true, message: "invalid request data" };

  const cmd = bytes[0];
  if (cmd !== 0x01) {
    return { hasError: true, message: "unsupported command; only CONNECT (0x01) allowed" };
  }

  const atype = bytes[1];
  let idx = 2;
  let address = "";

  if (atype === 0x01) {
    // IPv4
    if (bytes.length < idx + 4) return { hasError: true, message: "truncated IPv4" };
    address = `${bytes[idx++]}.${bytes[idx++]}.${bytes[idx++]}.${bytes[idx++]}`;
  } else 
  
  if (atype === 0x03) {
    // DOMAIN
    if (bytes.length < idx + 1) return { hasError: true, message: "truncated domain length" };
    const len = bytes[idx++];
    if (bytes.length < idx + len) return { hasError: true, message: "truncated domain name" };
    address = textDecoder.decode(bytes.slice(idx, idx + len));
    idx += len;
  } else 
  
  if (atype === 0x04) {
    // IPv6
    if (bytes.length < idx + 16) return { hasError: true, message: "truncated IPv6" };
    const seg = [];
    for (let i = 0; i < 16; i += 2) {
      seg.push(((bytes[idx + i] << 8) | bytes[idx + i + 1]).toString(16));
    }
    address = seg.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3"); // simple compression
    idx += 16;
  } else 
  
  {
    return { hasError: true, message: `invalid address type ${atype}` };
  }

  // 3) Port (2 bytes, big-endian)
  if (bytes.length < idx + 2) return { hasError: true, message: "missing port" };
  const portRemote = (bytes[idx] << 8) | bytes[idx + 1];
  idx += 2;

  // 4) CRLF after port
  if (bytes.length < idx + 2) return { hasError: true, message: "missing CRLF after port" };
  if (!(bytes[idx] === 0x0d && bytes[idx + 1] === 0x0a)) {
    return { hasError: true, message: "invalid header format (CRLF after port missing)" };
  }
  idx += 2;

  // 5) Remaining data is the initial payload
  const rawClientData = bytes.slice(idx).buffer;

  return {
    hasError: false,
    addressRemote: address,
    portRemote,
    rawClientData,
    passwordFromClient,
  };
}

/**
 * Extract password and remaining bytes from a Trojan header buffer.
 * Looks for the first CRLF and splits there.
 */
function extractPasswordAndRest(buffer) {
  try {
    const bytes = new Uint8Array(buffer);
    const cr = 0x0d, lf = 0x0a;
    let idx = -1;
    for (let i = 0; i + 1 < bytes.length; i++) {
      if (bytes[i] === cr && bytes[i + 1] === lf) { idx = i; break; }
    }
    
    if (idx === -1) return { error: "invalid header format (CRLF missing)" };
    const pwdBytes = bytes.slice(0, idx);
    const rest = bytes.slice(idx + 2).buffer;
    const passwordFromClient = textDecoder.decode(pwdBytes);
    return { passwordFromClient, rest, error: null };
    
  } catch (e) {
    return { error: "password extraction error" };
  }
}

//-----------------------------------------------------------------------------
// Handle Outbound TCP: always use proxyIP if provided for constant speed
//-----------------------------------------------------------------------------
/**
 * Handles outbound TCP connections by establishing a connection and piping data.
 *
 * @param {{value: any}} remoteSocketWrapper - Wrapper for the remote socket.
 * @param {string} addressRemote - The target address.
 * @param {number} portRemote - The target port.
 * @param {ArrayBuffer} rawClientData - The initial data chunk from the client.
 * @param {WebSocket} webSocket - The WebSocket used for forwarding data.
 * @param {(msg: string, err?: any) => void} log - Logging callback.
 */
async function handleTCPOutbound(
  remoteSocketWrapper,
  addressRemote,
  portRemote,
  rawClientData,
  webSocket,
  log
) {
    
  /**
   * Connects to a TCP socket and writes initial data.
   * @param {string} address - Destination IP or hostname.
   * @param {number} port - Destination port.
   * @returns {Promise<any>} - The connected TCP socket.
   */
  const connectAndWrite = async (address, port) => {
    log(`Connecting to ${address}:${port}`);
    // Plain TCP connect — exactly like Index.js. Trojan is a TCP proxy protocol;
    // TLS is handled by the client, NOT by this worker.
    const tcpSocket = connect({ hostname: address, port: port });
    remoteSocketWrapper.value = tcpSocket;
    const writer = tcpSocket.writable.getWriter();
    try {
      await writer.write(rawClientData);
    } catch (err) {
      log("Error writing initial data to TCP socket", err);
      throw err;
    } finally {
      writer.releaseLock();
    }
    return tcpSocket;
  };

  /**
   * Parses a proxyIP string ("host:port" or "[ipv6]:port") into {host, port}.
   * Returns null if the string is empty/invalid instead of throwing,
   * so callers can decide gracefully what to do.
   */
  const parseProxyIP = (proxy) => {
    if (!proxy || !proxy.trim()) return null;

    // IPv6 with brackets: [::1]:443
    const ipv6Match = proxy.match(/^\[(.+)]:(\d+)$/);
    if (ipv6Match) {
      return { host: ipv6Match[1], port: Number(ipv6Match[2]) };
    }

    // IPv4 or hostname with port: example.com:443
    const lastColon = proxy.lastIndexOf(":");
    if (lastColon > 0) {
      const host = proxy.substring(0, lastColon);
      const port = Number(proxy.substring(lastColon + 1));
      if (!isNaN(port) && port > 0 && port <= 65535) {
        return { host, port };
      }
    }

    return null;
  };

  /**
   * Plain (non-TLS) connect + write — used for proxyIP relay connections.
   * ProxyIP is a TCP relay, not a TLS endpoint; forcing TLS here will break it.
   */
  const connectAndWritePlain = async (address, port) => {
    log(`Connecting (plain TCP) to proxy ${address}:${port}`);
    let tcpSocket;
    try {
      tcpSocket = connect({ hostname: address, port, allowHalfOpen: false });
    } catch (err) {
      throw new Error(`Plain connect failed for ${address}:${port} - ${err}`);
    }
    remoteSocketWrapper.value = tcpSocket;
    const writer = tcpSocket.writable.getWriter();
    try {
      await writer.write(rawClientData);
    } catch (err) {
      log("Error writing initial data to proxy TCP socket", err);
      throw err;
    } finally {
      writer.releaseLock();
    }
    return tcpSocket;
  };

  /**
   * Retry: if PROXYIP is set, try it via plain TCP. Otherwise direct TLS.
   */
  const retry = async () => {
    const parsed = parseProxyIP(proxyIP);
    if (parsed) {
      log(`Retrying via proxyIP → ${parsed.host}:${parsed.port}`);
      try {
        const tcpSocket = await connectAndWritePlain(parsed.host, parsed.port);
        tcpSocket.closed
          .catch(err => log(`Retry TCP closed error`, err))
          .finally(() => { try { if (typeof tcpSocket.close === "function") tcpSocket.close(); } catch {} safeCloseWebSocket(webSocket); });
        remoteSocketToWS(tcpSocket, webSocket, null, log);
      } catch (err) {
        log(`Retry failed: ${err}`);
        safeCloseWebSocket(webSocket);
      }
    } else {
      log(`No proxyIP — giving up`);
      safeCloseWebSocket(webSocket);
    }
  };

  try {
    const tcpSocket = await connectAndWrite(addressRemote, portRemote);

    tcpSocket.closed
      .catch((err) => log(`TCP socket closed error for ${addressRemote}:${portRemote}`, err))
      .finally(() => {
        try { if (typeof tcpSocket.close === "function") tcpSocket.close(); } catch {}
        // Always close the WebSocket when the TCP side closes — same as Index.js
        safeCloseWebSocket(webSocket);
      });

    remoteSocketToWS(tcpSocket, webSocket, retry, log);
    
  } catch (err) {
    log(`TCP outbound connection failed for ${addressRemote}:${portRemote}`, err);
    await retry();
  }
}

//-----------------------------------------------------------------------------
// Pipe TCP → WebSocket
//-----------------------------------------------------------------------------
/**
 * Pipes data from a TCP socket to a WebSocket with proper backpressure and cleanup.
 *
 * @param {any} remoteSocket - The TCP socket.
 * @param {WebSocket} webSocket - The WebSocket.
 * @param {(() => Promise<void>) | null} retry - Optional retry function on connection drop.
 * @param {(msg: string, err?: any) => void} log - Logging callback.
 */
async function remoteSocketToWS(remoteSocket, webSocket, retry, log) {
  const protocol = webSocket.protocol?.toLowerCase();
  const isLowLatency = protocol === "voip";
  let hasIncomingData = false;

  try {
    if (isLowLatency) {
      const reader = remoteSocket.readable.getReader();
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        hasIncomingData = true;
        if (webSocket.readyState === 1) {
          webSocket.send(value);
        } else {
          throw new Error("WebSocket not open");
        }
      }
    } else {
      
      await remoteSocket.readable.pipeTo(
        new WritableStream({
          async write(chunk) {
            hasIncomingData = true;
            if (webSocket.readyState !== 1) throw new Error("WebSocket not open");
            webSocket.send(chunk);
          },
          close() {
            log(`TCP stream closed; data received: ${hasIncomingData}`);
          },
          abort(reason) {
            console.error("TCP stream aborted:", reason);
          },
        })
      );
    }
    
  } catch (error) {
      
    console.error("remoteSocketToWS error:", error);

    safeCloseWebSocket(webSocket);
    if (retry) {
      log("Connection dropped. Attempting reconnect...");
      await retry();
    }
  }

  if (!hasIncomingData && retry && !isLowLatency) {
    log("No incoming data detected; retrying connection.");
    await retry();
  }
}

//-----------------------------------------------------------------------------
// Convert WebSocket messages to a ReadableStream (binary only) with earlyData
//-----------------------------------------------------------------------------
/**
 * Creates a readable stream from a WebSocket with improved state management.
 *
 * @param {WebSocket} webSocketServer - The WebSocket server instance.
 * @param {string} earlyDataHeader - Optional early data in base64 format.
 * @param {(msg: string, err?: any) => void} log - Logging callback.
 * @returns {ReadableStream<Uint8Array>}
 */
function makeReadableWebSocketStream(webSocketServer, earlyDataHeader, log) {
  let canceled = false;
  let controller;
  
  // Pre-create text encoder instance to avoid repeated instantiation
  const encoder = new TextEncoder();
  
  // Optimized message handler with reduced function calls
  const onMessage = (event) => {
    if (canceled) return;
    
    const data = event.data;
    const dataType = typeof data;
    
    if (dataType === "string") {
      controller.enqueue(encoder.encode(data));
    } else if (data instanceof Blob) {
      // Use more efficient blob handling with proper error handling
      data.arrayBuffer().then(
        buffer => !canceled && controller.enqueue(new Uint8Array(buffer)),
        err => !canceled && controller.error(new Error(`Blob conversion failed: ${err.message}`))
      );
    } else {
      // Assume it's already a buffer-like object
      controller.enqueue(data);
    }
  };
  
  // Centralized cleanup function to reduce code duplication
  const cleanup = () => {
    webSocketServer.removeEventListener("message", onMessage);
    webSocketServer.removeEventListener("close", onClose);
    webSocketServer.removeEventListener("error", onError);
  };
  
  const onClose = () => {
    cleanup();
    if (!canceled) {
      try {
        controller.close();
      } catch (e) {
        // Controller might already be closed, ignore error
      }
    }
  };
  
  const onError = (err) => {
    cleanup();
    if (!canceled) {
      controller.error(err);
    }
  };
  
  return new ReadableStream({
    start(ctrl) {
      controller = ctrl;
      
      // Add event listeners
      webSocketServer.addEventListener("message", onMessage);
      webSocketServer.addEventListener("close", onClose);
      webSocketServer.addEventListener("error", onError);
      
      // Handle early data more efficiently
      if (earlyDataHeader) {
        try {
          const { earlyData, error } = base64ToArrayBuffer(earlyDataHeader);
          if (error) {
            ctrl.error(error);
          } else if (earlyData && earlyData.length > 0) {
            ctrl.enqueue(earlyData);
          }
          
        } catch (err) {
          ctrl.error(new Error(`Early data processing failed: ${err.message}`));
        }
      }
    },
    
    cancel(reason) {
      if (canceled) return;
      canceled = true;
      
      // Use optional chaining for safer logging
      log?.(`Stream canceled: ${reason}`);
      
      cleanup();
      
      // Safe WebSocket closure with error handling
      try {
        safeCloseWebSocket(webSocketServer);
        
      } catch (err) {
        // Log error but don't throw to avoid masking the original cancellation reason
        log?.(`WebSocket close error: ${err.message}`);
      }
    },
  });
}


//-----------------------------------------------------------------------------
// WebSocket State Constants
//-----------------------------------------------------------------------------
/** WebSocket constants for comprehensive state checking. */
const WS_READY_STATE_CONNECTING = 0;
const WS_READY_STATE_OPEN = 1;
const WS_READY_STATE_CLOSING = 2;
const WS_READY_STATE_CLOSED = 3;

//-----------------------------------------------------------------------------
// Safe WebSocket Closure
//-----------------------------------------------------------------------------
/**
 * Safely closes a WebSocket connection with proper error handling and cleanup.
 * 
 * This function ensures graceful closure by:
 * - Validating the socket object exists and has the expected structure
 * - Checking if the socket is in a closeable state
 * - Providing comprehensive error logging
 * - Preventing multiple closure attempts
 *
 * @param {WebSocket | null | undefined} socket - The WebSocket instance to close
 * @param {number} [code=1000] - The close code (default: 1000 = normal closure)
 * @param {string} [reason=''] - Optional reason for closure
 * @returns {boolean} - Returns true if closure was attempted, false otherwise
 */
function safeCloseWebSocket(socket, code = 1000, reason = '') {
  try {
    // Validate socket exists and has readyState property
    if (!socket || typeof socket.readyState !== 'number') {
      console.warn('Invalid WebSocket provided to safeCloseWebSocket');
      return false;
    }

    // Only attempt to close if socket is open or closing
    if (socket.readyState === WS_READY_STATE_OPEN || socket.readyState === WS_READY_STATE_CLOSING) {
      socket.close(code, reason);
      console.debug(`WebSocket closed with code: ${code}, reason: ${reason || 'No reason provided'}`);
      return true;
    }

    // Log current state for debugging
    const stateNames = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
    console.debug(`WebSocket already in ${stateNames[socket.readyState]} state, no action needed`);
    return false;

  } catch (error) {
    console.error('Error during WebSocket closure:', {
      error: error.message,
      stack: error.stack,
      socketState: socket?.readyState ?? 'unknown'
    });
    return false;
  }
}

//-----------------------------------------------------------------------------
// Generate Trojan nodes — same clean format as Index.js (ECH off baseline)
// 10 nodes: worker hostname + 9 CF anycast IPs, all with SNI=workerDomain
//-----------------------------------------------------------------------------
function generateTrojanNodes(pwd, hostName) {
  const links = [];

  const makeLink = (server, label) => {
    // Matches Index.js generateTrojanLinksFromSource exactly (ECH disabled path):
    // security=tls, sni=workerDomain, fp=randomized, type=ws, host=workerDomain, path=/?ed=2048
    // No alpn, no ech — universally compatible
    const params = new URLSearchParams({
      security:      'tls',
      sni:           hostName,
      fp:            'randomized',
      type:          'ws',
      host:          hostName,
      path:          '/?ed=2048',
    });
    return 'trojan://' + encodeURIComponent(pwd) + '@' + server + ':443?' + params.toString() + '#' + encodeURIComponent(label);
  };

  // 1. Primary — worker hostname (CF routes to nearest PoP automatically)
  links.push(makeLink(hostName, hostName + ' [Direct]'));

  // 2. CF anycast IPs — client connects to these IPs, SNI=hostName routes to correct worker
  const cfIPs = [
    ['104.21.0.1',    'CF-US-1'],
    ['172.67.0.1',    'CF-US-2'],
    ['162.159.0.1',   'CF-US-3'],
    ['104.16.0.1',    'CF-US-4'],
    ['104.17.0.1',    'CF-US-5'],
    ['141.101.64.1',  'CF-EU-1'],
    ['108.162.192.1', 'CF-EU-2'],
    ['190.93.240.1',  'CF-AP-1'],
    ['188.114.96.1',  'CF-AP-2'],
  ];

  for (const [ip, label] of cfIPs) {
    links.push(makeLink(ip, label));
  }

  return links;
}

//-----------------------------------------------------------------------------
// Generate Clash YAML via the subscription converter service
//-----------------------------------------------------------------------------
async function generateClashConfig(nodes, request, pwd, hostName) {
  // Build the base64 sub URL pointing back to this worker
  const subUrl = new URL(request.url);
  subUrl.pathname = `/${pwd}/sub`;
  subUrl.search = '?target=base64';
  const encodedSubUrl = encodeURIComponent(subUrl.toString());
  const converterUrl = `${scu}?target=clash&url=${encodedSubUrl}&insert=false&config=${encodeURIComponent(remoteConfigUrl)}&emoji=true&list=false&xudp=false&udp=false&tfo=false&expand=true&scv=false&fdn=false&new_name=true`;

  const response = await fetch(converterUrl);
  if (!response.ok) throw new Error(`Converter returned ${response.status}`);

  let clashConfig = await response.text();

  // Inject ech-opts into every proxy node line
  const echDomain = customECHDomain || 'cloudflare-ech.com';
  clashConfig = clashConfig.split('\n').map(line => {
    if (/^\s*-\s*\{/.test(line) && line.includes('name:') && line.includes('server:')) {
      if (line.includes('ech-opts')) return line;
      const lastBrace = line.lastIndexOf('}');
      if (lastBrace > 0) {
        const before = line.substring(0, lastBrace).trim();
        const needsComma = !before.endsWith(',') && !before.endsWith('{');
        return line.substring(0, lastBrace) +
          (needsComma ? ', ' : ' ') +
          `ech-opts: {enable: true, query-server-name: ${echDomain}}` +
          line.substring(lastBrace);
      }
    }
    return line;
  }).join('\n');

  // Replace DNS nameserver with the configured DoH
  const dnsServer = customDNS || 'https://cloudflare-dns.com/dns-query';
  clashConfig = clashConfig.replace(
    /^(\s*nameserver:\s*\n)((?:\s*-\s*[^\n]+\n)*)/m,
    (_, header) => header + `    - ${dnsServer}\n`
  );

  return clashConfig;
}

//-----------------------------------------------------------------------------
// Serve the Trojan config page with V2Ray and Clash subscription links
//-----------------------------------------------------------------------------
function serveConfigPage(pwd, hostName) {
  const subBase = `https://${hostName}/${pwd}/sub`;
  const v2rayLink = subBase;                           // base64 — universal V2Ray import
  const clashLink = `${scu}?target=clash&url=${encodeURIComponent(subBase + '?target=base64')}&insert=false&config=${encodeURIComponent(remoteConfigUrl)}&emoji=true&list=false&xudp=false&udp=false&tfo=false&expand=true&scv=false&fdn=false&new_name=true`;
  const trojanLink = buildTrojanLink(pwd, hostName);

  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Trojan Config</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Syne:wght@700;800&display=swap');
  :root {
    --bg: #0a0a0f;
    --surface: #12121a;
    --border: #1e1e2e;
    --accent: #7c3aed;
    --accent2: #06b6d4;
    --text: #e2e8f0;
    --muted: #64748b;
    --success: #10b981;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 2rem;
    background-image:
      radial-gradient(ellipse 80% 50% at 20% 20%, rgba(124,58,237,0.08) 0%, transparent 60%),
      radial-gradient(ellipse 60% 40% at 80% 80%, rgba(6,182,212,0.06) 0%, transparent 60%);
  }
  .container { max-width: 720px; width: 100%; }
  .header { margin-bottom: 2.5rem; }
  .header h1 {
    font-family: 'Syne', sans-serif;
    font-size: 2rem;
    font-weight: 800;
    letter-spacing: -0.03em;
    background: linear-gradient(135deg, #7c3aed, #06b6d4);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 0.4rem;
  }
  .header p { color: var(--muted); font-size: 0.8rem; }
  .badge {
    display: inline-flex; align-items: center; gap: 0.4rem;
    background: rgba(16,185,129,0.1); border: 1px solid rgba(16,185,129,0.3);
    color: var(--success); padding: 0.25rem 0.75rem; border-radius: 999px;
    font-size: 0.7rem; font-weight: 600; margin-top: 0.75rem;
    letter-spacing: 0.05em; text-transform: uppercase;
  }
  .badge::before { content: '●'; font-size: 0.6rem; }
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 1rem;
    position: relative;
    overflow: hidden;
    transition: border-color 0.2s;
  }
  .card:hover { border-color: #2a2a3e; }
  .card::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 2px;
  }
  .card.trojan::before { background: linear-gradient(90deg, #7c3aed, transparent); }
  .card.v2ray::before  { background: linear-gradient(90deg, #06b6d4, transparent); }
  .card.clash::before  { background: linear-gradient(90deg, #f59e0b, transparent); }
  .card-label {
    font-size: 0.65rem; font-weight: 700; letter-spacing: 0.12em;
    text-transform: uppercase; margin-bottom: 0.75rem;
    display: flex; align-items: center; gap: 0.5rem;
  }
  .card.trojan .card-label { color: #7c3aed; }
  .card.v2ray  .card-label { color: #06b6d4; }
  .card.clash  .card-label { color: #f59e0b; }
  .link-row {
    display: flex; align-items: stretch; gap: 0.5rem;
  }
  .link-box {
    flex: 1;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.75rem 1rem;
    font-size: 0.72rem;
    color: var(--muted);
    word-break: break-all;
    line-height: 1.5;
    cursor: text;
    user-select: all;
    transition: border-color 0.2s, color 0.2s;
    min-height: 3rem;
    display: flex;
    align-items: center;
  }
  .link-box:focus-within,
  .link-box:hover { border-color: #2a2a3e; color: var(--text); }
  .copy-btn {
    background: rgba(124,58,237,0.15);
    border: 1px solid rgba(124,58,237,0.3);
    color: #7c3aed;
    border-radius: 8px;
    padding: 0 1rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    font-weight: 600;
    cursor: pointer;
    white-space: nowrap;
    transition: all 0.15s;
    letter-spacing: 0.05em;
  }
  .copy-btn:hover { background: rgba(124,58,237,0.25); border-color: #7c3aed; }
  .copy-btn.v { background: rgba(6,182,212,0.15); border-color: rgba(6,182,212,0.3); color: #06b6d4; }
  .copy-btn.v:hover { background: rgba(6,182,212,0.25); border-color: #06b6d4; }
  .copy-btn.c { background: rgba(245,158,11,0.15); border-color: rgba(245,158,11,0.3); color: #f59e0b; }
  .copy-btn.c:hover { background: rgba(245,158,11,0.25); border-color: #f59e0b; }
  .copy-btn.copied { color: var(--success) !important; border-color: var(--success) !important; }
  .hint {
    margin-top: 0.6rem;
    font-size: 0.65rem;
    color: var(--muted);
    line-height: 1.5;
  }
  .footer {
    margin-top: 2rem;
    text-align: center;
    font-size: 0.65rem;
    color: #2a2a3e;
  }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>Trojan Config</h1>
    <p>${hostName}</p>
    <div class="badge">trojan · workers.dev</div>
  </div>

  <div class="card trojan">
    <div class="card-label">⬡ Trojan Link</div>
    <div class="link-row">
      <div class="link-box" id="trojan-box">${trojanLink}</div>
      <button class="copy-btn" onclick="copy('trojan-box', this)">COPY</button>
    </div>
    <div class="hint">Single node — import directly into any Trojan/V2RayN/Clash client.</div>
  </div>

  <div class="card v2ray">
    <div class="card-label">⬡ V2Ray Subscription</div>
    <div class="link-row">
      <div class="link-box" id="v2ray-box">${v2rayLink}</div>
      <button class="copy-btn v" onclick="copy('v2ray-box', this)">COPY</button>
    </div>
    <div class="hint">Base64 sub — 10 nodes (worker hostname + 9 CF anycast IPs, all with ECH). Import into V2RayN, Shadowrocket, Nekoray, etc.</div>
  </div>

  <div class="card clash">
    <div class="card-label">⬡ Clash Subscription</div>
    <div class="link-row">
      <div class="link-box" id="clash-box">${clashLink}</div>
      <button class="copy-btn c" onclick="copy('clash-box', this)">COPY</button>
    </div>
    <div class="hint">Clash YAML via url.v1.mk converter · ECH injected · rule config from byJoey/test.</div>
  </div>

  <div class="footer">trojan-worker</div>
</div>
<script>
function copy(id, btn) {
  const text = document.getElementById(id).textContent.trim();
  navigator.clipboard.writeText(text).then(() => {
    const orig = btn.textContent;
    btn.textContent = 'COPIED';
    btn.classList.add('copied');
    setTimeout(() => { btn.textContent = orig; btn.classList.remove('copied'); }, 1800);
  });
}
</script>
</body>
</html>`;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/**
 * Builds a Trojan WebSocket link string. When ECH is enabled, adds
 * ECH parameters and sets fingerprint to 'chrome' (required for ECH).
 *
 * @param {string} pwd - The Trojan password.
 * @param {string} hostName - The worker hostname.
 * @returns {string} The Trojan URI.
 */
function buildTrojanLink(pwd, hostName) {
  // Clean link — no alpn, no ech — works with every client (v2rayN, Nekoray, Shadowrocket, Clash)
  // path=/?ed=2048 matches Index.js exactly (enables WS early-data on supported clients, ignored otherwise)
  const params = new URLSearchParams({
    security:      'tls',
    sni:           hostName,
    fp:            'randomized',
    type:          'ws',
    host:          hostName,
    path:          '/?ed=2048',
  });

  return 'trojan://' + encodeURIComponent(pwd) + '@' + hostName + ':443?' + params.toString() + '#' + encodeURIComponent(hostName);
}

//-----------------------------------------------------------------------------
/**
 * Converts a base64-encoded string to an ArrayBuffer.
 * Supports both standard and URL-safe base64 encoding formats.
 *
 * @param {string} base64Str - The base64 string to convert.
 * @returns {{earlyData?: ArrayBuffer, error: Error | null}}
 */
function base64ToArrayBuffer(base64Str) {
  if (!base64Str || typeof base64Str !== 'string') {
    return { earlyData: undefined, error: null };
  }

  try {
    // Convert URL-safe base64 to standard base64
    let normalizedBase64 = base64Str.replace(/-/g, '+').replace(/_/g, '/');
    
    // Add padding if necessary
    const padding = normalizedBase64.length % 4;
    if (padding) {
      normalizedBase64 += '='.repeat(4 - padding);
    }
    
    // Decode base64 string
    const binaryString = atob(normalizedBase64);
    const length = binaryString.length;
    
    // Create Uint8Array more efficiently
    const uint8Array = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
      uint8Array[i] = binaryString.charCodeAt(i);
    }
    
    return { earlyData: uint8Array.buffer, error: null };
    
  } catch (error) {
    // Create a more descriptive error
    const enhancedError = new Error(`Failed to convert base64 to ArrayBuffer: ${error.message}`);
    enhancedError.originalError = error;
    return { earlyData: undefined, error: enhancedError };
  }
}

//-----------------------------------------------------------------------------
// HTTP(S) Homepage Endpoint
//-----------------------------------------------------------------------------
/**
 * Serves the homepage with additional security headers.
 * @param {any} env - The deployment environment for obtaining CACHE_CONTROL.
 * @returns {Response} The response containing the homepage HTML.
 */
function serveHomepage(env) {
  const headers = new Headers({
    "Content-Type": "text/html;charset=utf-8",
    Connection: "keep-alive",
    "Cache-Control": env.CACHE_CONTROL || "public",
    "X-Content-Type-Options": "nosniff",
    "X-Frame-Options": "DENY",
    "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
  });

  return new Response(cachedHomepageHTML, { status: 200, headers });
}

/**
 * Returns the Cloudflare homepage HTML.
 */

const cachedHomepageHTML = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Cloudflare! ⛅️</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        :root {
            --primary: #F38020;
            --background: #000;
            --text: #fff;
            --card-bg: rgba(255, 255, 255, 0.08);
            --border-color: rgba(255, 255, 255, 0.15);
            --gradient: linear-gradient(135deg, #F38020, #FFA927);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: var(--background);
            color: var(--text);
            font-family: 'Inter', sans-serif;
            padding: 2rem;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
        }
        
        .container {
            max-width: 650px;
            width: 100%;
            text-align: center;
            padding: 3rem;
            background: var(--card-bg);
            border-radius: 20px;
            border: 1px solid var(--border-color);
            backdrop-filter: blur(15px);
            box-shadow: 0 15px 40px rgba(255, 255, 255, 0.08);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .container:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 50px rgba(255, 255, 255, 0.15);
        }
        
        .logo {
            width: 100px;
            margin-bottom: 2rem;
        }
        
        .imgur-image {
            width: 100%;
            height: auto;
            border-radius: 10px;
            margin-bottom: 2rem;
            display: block;
            object-fit: contain;
        }
        
        h1 {
            font-size: 2.4rem;
            margin-bottom: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
        }
        
        p {
            font-size: 1.2rem;
            opacity: 0.85;
            margin-bottom: 1.8rem;
        }
        
        .message {
            font-size: 1rem;
            opacity: 0.7;
            margin-bottom: 2rem;
        }
        
        .links {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 2rem;
        }
        
        .link-card {
            padding: 1rem 1.5rem;
            border-radius: 14px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            backdrop-filter: blur(8px);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .link-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 255, 255, 0.15);
        }
        
        a {
            display: block;
            font-size: 1rem;
            font-weight: 600;
            color: var(--primary);
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        a:hover {
            color: #FFA927;
        }
        
        em {
            display: block;
            margin-top: 2rem;
            font-size: 0.9rem;
            opacity: 0.65;
        }
        
        @media (max-width: 640px) {
            .container {
                padding: 2rem;
            }
            h1 {
                font-size: 2rem;
            }
            .links {
                flex-direction: column;
                gap: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Cloudflare_Logo.svg/512px-Cloudflare_Logo.svg.png" alt="Cloudflare Logo" class="logo">
        <h1>Welcome to Cloudflare!</h1>
        <p>Your Cloudflare services are successfully configured and operational.</p>
        <img src="https://i.imgur.com/4XvzrJJ.jpg" alt="Cloudflare Network" class="imgur-image">
        <p class="message">A faster, safer, and more reliable internet powered by Cloudflare.</p>
        <div class="links">
            <div class="link-card">
                <a href="https://developers.cloudflare.com/">Docs →</a>
            </div>
            <div class="link-card">
                <a href="https://community.cloudflare.com/">Community →</a>
            </div>
        </div>
        <em>Cloudflare's global edge network</em>
    </div>
</body>
</html>
`;

//-----------------------------------------------------------------------------
// SHA-256
//-----------------------------------------------------------------------------
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.11.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2024
 * @license MIT
 */
(function () 
{
  "use strict";

  var ERROR = "input is invalid type";
  var WINDOW = typeof window === "object";
  var root = WINDOW ? window : {};
  if (root.JS_SHA256_NO_WINDOW) {
    WINDOW = false;
  }
  
  var WEB_WORKER = !WINDOW && typeof self === "object";
  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  
  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
  var AMD = typeof define === "function" && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
  var HEX_CHARS = "0123456789abcdef".split("");
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98,
    0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8,
    0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7,
    0xc67178f2,
  ];
  
  var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];

  var blocks = [];

  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) 
  {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (outputType, is224) 
  {
    return function (message) {
      return new Sha256(is224, true).update(message)[outputType]();
    };
  };

  var createMethod = function (is224) 
  {
    var method = createOutputMethod("hex", is224);
    if (NODE_JS) {
      method = nodeWrap(method, is224);
    }
    method.create = function () {
      return new Sha256(is224);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type, is224);
    }
    return method;
  };

  var nodeWrap = function (method, is224) 
  {
    var crypto = require("crypto");
    var Buffer = require("buffer").Buffer;
    var algorithm = is224 ? "sha224" : "sha256";
    var bufferFrom;
    if (Buffer.from && !root.JS_SHA256_NO_BUFFER_FROM) {
      bufferFrom = Buffer.from;
    } else {
      bufferFrom = function (message) {
        return new Buffer(message);
      };
    }
    
    var nodeMethod = function (message) {
      if (typeof message === "string") {
        return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
      } else {
        if (message === null || message === undefined) {
          throw new Error(ERROR);
        } else if (message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        }
      }
      
      if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
        return crypto.createHash(algorithm).update(bufferFrom(message)).digest("hex");
      } else {
        return method(message);
      }
    };
    return nodeMethod;
  };

  var createHmacOutputMethod = function (outputType, is224) 
  {
    return function (key, message) {
      return new HmacSha256(key, is224, true).update(message)[outputType]();
    };
  };

  var createHmacMethod = function (is224) 
  {
    var method = createHmacOutputMethod("hex", is224);
    method.create = function (key) {
      return new HmacSha256(key, is224);
    };
    method.update = function (key, message) {
      return method.create(key).update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createHmacOutputMethod(type, is224);
    }
    return method;
  };

  function Sha256(is224, sharedMemory) 
  {
    if (sharedMemory) {
      blocks[0] =
        blocks[16] =
        blocks[1] =
        blocks[2] =
        blocks[3] =
        blocks[4] =
        blocks[5] =
        blocks[6] =
        blocks[7] =
        blocks[8] =
        blocks[9] =
        blocks[10] =
        blocks[11] =
        blocks[12] =
        blocks[13] =
        blocks[14] =
        blocks[15] =
          0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    if (is224) 
    {
      this.h0 = 0xc1059ed8;
      this.h1 = 0x367cd507;
      this.h2 = 0x3070dd17;
      this.h3 = 0xf70e5939;
      this.h4 = 0xffc00b31;
      this.h5 = 0x68581511;
      this.h6 = 0x64f98fa7;
      this.h7 = 0xbefa4fa4;
    } else {
      // 256
      this.h0 = 0x6a09e667;
      this.h1 = 0xbb67ae85;
      this.h2 = 0x3c6ef372;
      this.h3 = 0xa54ff53a;
      this.h4 = 0x510e527f;
      this.h5 = 0x9b05688c;
      this.h6 = 0x1f83d9ab;
      this.h7 = 0x5be0cd19;
    }

    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
    this.is224 = is224;
  }

  Sha256.prototype.update = function (message) 
  {
    if (this.finalized) {
      return;
    }
    
    var notString,
      type = typeof message;
    if (type !== "string") {
      if (type === "object") {
        if (message === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
      notString = true;
    }
    
    var code,
      index = 0,
      i,
      length = message.length,
      blocks = this.blocks;
    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = this.block;
        this.block =
          blocks[16] =
          blocks[1] =
          blocks[2] =
          blocks[3] =
          blocks[4] =
          blocks[5] =
          blocks[6] =
          blocks[7] =
          blocks[8] =
          blocks[9] =
          blocks[10] =
          blocks[11] =
          blocks[12] =
          blocks[13] =
          blocks[14] =
          blocks[15] =
            0;
      }

      if (notString) {
        for (i = this.start; index < length && i < 64; ++index) {
          blocks[i >>> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } 
      
      else 
      {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >>> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >>> 2] |= (0xc0 | (code >>> 6)) << SHIFT[i++ & 3];
            blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >>> 2] |= (0xe0 | (code >>> 12)) << SHIFT[i++ & 3];
            blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >>> 2] |= (0xf0 | (code >>> 18)) << SHIFT[i++ & 3];
            blocks[i >>> 2] |= (0x80 | ((code >>> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }

      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.block = blocks[16];
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    
    if (this.bytes > 4294967295) {
      this.hBytes += (this.bytes / 4294967296) << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };

  Sha256.prototype.finalize = function () 
  {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks,
      i = this.lastByteIndex;
    blocks[16] = this.block;
    blocks[i >>> 2] |= EXTRA[i & 3];
    this.block = blocks[16];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = this.block;
      blocks[16] =
        blocks[1] =
        blocks[2] =
        blocks[3] =
        blocks[4] =
        blocks[5] =
        blocks[6] =
        blocks[7] =
        blocks[8] =
        blocks[9] =
        blocks[10] =
        blocks[11] =
        blocks[12] =
        blocks[13] =
        blocks[14] =
        blocks[15] =
          0;
    }
    blocks[14] = (this.hBytes << 3) | (this.bytes >>> 29);
    blocks[15] = this.bytes << 3;
    this.hash();
  };

  Sha256.prototype.hash = function () 
  {
    var a = this.h0,
      b = this.h1,
      c = this.h2,
      d = this.h3,
      e = this.h4,
      f = this.h5,
      g = this.h6,
      h = this.h7,
      blocks = this.blocks,
      j,
      s0,
      s1,
      maj,
      t1,
      t2,
      ch,
      ab,
      da,
      cd,
      bc;

    for (j = 16; j < 64; ++j) {
      t1 = blocks[j - 15];
      s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
      t1 = blocks[j - 2];
      s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
      blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;
    }

    bc = b & c;
    for (j = 0; j < 64; j += 4) {
      if (this.first) {
        if (this.is224) {
          ab = 300032;
          t1 = blocks[0] - 1413257819;
          h = (t1 - 150054599) << 0;
          d = (t1 + 24177077) << 0;
        } else {
          ab = 704751109;
          t1 = blocks[0] - 210244248;
          h = (t1 - 1521486534) << 0;
          d = (t1 + 143694565) << 0;
        }
        this.first = false;
      } else {
        s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
        s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
        ab = a & b;
        maj = ab ^ (a & c) ^ bc;
        ch = (e & f) ^ (~e & g);
        t1 = h + s1 + ch + K[j] + blocks[j];
        t2 = s0 + maj;
        h = (d + t1) << 0;
        d = (t1 + t2) << 0;
      }
      s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));
      s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));
      da = d & a;
      maj = da ^ (d & b) ^ ab;
      ch = (h & e) ^ (~h & f);
      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
      t2 = s0 + maj;
      g = (c + t1) << 0;
      c = (t1 + t2) << 0;
      s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));
      s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));
      cd = c & d;
      maj = cd ^ (c & a) ^ da;
      ch = (g & h) ^ (~g & e);
      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
      t2 = s0 + maj;
      f = (b + t1) << 0;
      b = (t1 + t2) << 0;
      s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));
      s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));
      bc = b & c;
      maj = bc ^ (b & d) ^ cd;
      ch = (f & g) ^ (~f & h);
      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
      t2 = s0 + maj;
      e = (a + t1) << 0;
      a = (t1 + t2) << 0;
      this.chromeBugWorkAround = true;
    }

    this.h0 = (this.h0 + a) << 0;
    this.h1 = (this.h1 + b) << 0;
    this.h2 = (this.h2 + c) << 0;
    this.h3 = (this.h3 + d) << 0;
    this.h4 = (this.h4 + e) << 0;
    this.h5 = (this.h5 + f) << 0;
    this.h6 = (this.h6 + g) << 0;
    this.h7 = (this.h7 + h) << 0;
  };

  Sha256.prototype.hex = function () 
  {
    this.finalize();

    var h0 = this.h0,
      h1 = this.h1,
      h2 = this.h2,
      h3 = this.h3,
      h4 = this.h4,
      h5 = this.h5,
      h6 = this.h6,
      h7 = this.h7;

    var hex =
      HEX_CHARS[(h0 >>> 28) & 0x0f] +
      HEX_CHARS[(h0 >>> 24) & 0x0f] +
      HEX_CHARS[(h0 >>> 20) & 0x0f] +
      HEX_CHARS[(h0 >>> 16) & 0x0f] +
      HEX_CHARS[(h0 >>> 12) & 0x0f] +
      HEX_CHARS[(h0 >>> 8) & 0x0f] +
      HEX_CHARS[(h0 >>> 4) & 0x0f] +
      HEX_CHARS[h0 & 0x0f] +
      HEX_CHARS[(h1 >>> 28) & 0x0f] +
      HEX_CHARS[(h1 >>> 24) & 0x0f] +
      HEX_CHARS[(h1 >>> 20) & 0x0f] +
      HEX_CHARS[(h1 >>> 16) & 0x0f] +
      HEX_CHARS[(h1 >>> 12) & 0x0f] +
      HEX_CHARS[(h1 >>> 8) & 0x0f] +
      HEX_CHARS[(h1 >>> 4) & 0x0f] +
      HEX_CHARS[h1 & 0x0f] +
      HEX_CHARS[(h2 >>> 28) & 0x0f] +
      HEX_CHARS[(h2 >>> 24) & 0x0f] +
      HEX_CHARS[(h2 >>> 20) & 0x0f] +
      HEX_CHARS[(h2 >>> 16) & 0x0f] +
      HEX_CHARS[(h2 >>> 12) & 0x0f] +
      HEX_CHARS[(h2 >>> 8) & 0x0f] +
      HEX_CHARS[(h2 >>> 4) & 0x0f] +
      HEX_CHARS[h2 & 0x0f] +
      HEX_CHARS[(h3 >>> 28) & 0x0f] +
      HEX_CHARS[(h3 >>> 24) & 0x0f] +
      HEX_CHARS[(h3 >>> 20) & 0x0f] +
      HEX_CHARS[(h3 >>> 16) & 0x0f] +
      HEX_CHARS[(h3 >>> 12) & 0x0f] +
      HEX_CHARS[(h3 >>> 8) & 0x0f] +
      HEX_CHARS[(h3 >>> 4) & 0x0f] +
      HEX_CHARS[h3 & 0x0f] +
      HEX_CHARS[(h4 >>> 28) & 0x0f] +
      HEX_CHARS[(h4 >>> 24) & 0x0f] +
      HEX_CHARS[(h4 >>> 20) & 0x0f] +
      HEX_CHARS[(h4 >>> 16) & 0x0f] +
      HEX_CHARS[(h4 >>> 12) & 0x0f] +
      HEX_CHARS[(h4 >>> 8) & 0x0f] +
      HEX_CHARS[(h4 >>> 4) & 0x0f] +
      HEX_CHARS[h4 & 0x0f] +
      HEX_CHARS[(h5 >>> 28) & 0x0f] +
      HEX_CHARS[(h5 >>> 24) & 0x0f] +
      HEX_CHARS[(h5 >>> 20) & 0x0f] +
      HEX_CHARS[(h5 >>> 16) & 0x0f] +
      HEX_CHARS[(h5 >>> 12) & 0x0f] +
      HEX_CHARS[(h5 >>> 8) & 0x0f] +
      HEX_CHARS[(h5 >>> 4) & 0x0f] +
      HEX_CHARS[h5 & 0x0f] +
      HEX_CHARS[(h6 >>> 28) & 0x0f] +
      HEX_CHARS[(h6 >>> 24) & 0x0f] +
      HEX_CHARS[(h6 >>> 20) & 0x0f] +
      HEX_CHARS[(h6 >>> 16) & 0x0f] +
      HEX_CHARS[(h6 >>> 12) & 0x0f] +
      HEX_CHARS[(h6 >>> 8) & 0x0f] +
      HEX_CHARS[(h6 >>> 4) & 0x0f] +
      HEX_CHARS[h6 & 0x0f];
    if (!this.is224) {
      hex +=
        HEX_CHARS[(h7 >>> 28) & 0x0f] +
        HEX_CHARS[(h7 >>> 24) & 0x0f] +
        HEX_CHARS[(h7 >>> 20) & 0x0f] +
        HEX_CHARS[(h7 >>> 16) & 0x0f] +
        HEX_CHARS[(h7 >>> 12) & 0x0f] +
        HEX_CHARS[(h7 >>> 8) & 0x0f] +
        HEX_CHARS[(h7 >>> 4) & 0x0f] +
        HEX_CHARS[h7 & 0x0f];
    }
    return hex;
  };

  Sha256.prototype.toString = Sha256.prototype.hex;

  Sha256.prototype.digest = function () 
  {
    this.finalize();

    var h0 = this.h0,
      h1 = this.h1,
      h2 = this.h2,
      h3 = this.h3,
      h4 = this.h4,
      h5 = this.h5,
      h6 = this.h6,
      h7 = this.h7;

    var arr = [
      (h0 >>> 24) & 0xff,
      (h0 >>> 16) & 0xff,
      (h0 >>> 8) & 0xff,
      h0 & 0xff,
      (h1 >>> 24) & 0xff,
      (h1 >>> 16) & 0xff,
      (h1 >>> 8) & 0xff,
      h1 & 0xff,
      (h2 >>> 24) & 0xff,
      (h2 >>> 16) & 0xff,
      (h2 >>> 8) & 0xff,
      h2 & 0xff,
      (h3 >>> 24) & 0xff,
      (h3 >>> 16) & 0xff,
      (h3 >>> 8) & 0xff,
      h3 & 0xff,
      (h4 >>> 24) & 0xff,
      (h4 >>> 16) & 0xff,
      (h4 >>> 8) & 0xff,
      h4 & 0xff,
      (h5 >>> 24) & 0xff,
      (h5 >>> 16) & 0xff,
      (h5 >>> 8) & 0xff,
      h5 & 0xff,
      (h6 >>> 24) & 0xff,
      (h6 >>> 16) & 0xff,
      (h6 >>> 8) & 0xff,
      h6 & 0xff,
    ];
    
    if (!this.is224) {
      arr.push((h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, h7 & 0xff);
    }
    return arr;
  };

  Sha256.prototype.array = Sha256.prototype.digest;

  Sha256.prototype.arrayBuffer = function () 
  {
    this.finalize();

    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0);
    dataView.setUint32(4, this.h1);
    dataView.setUint32(8, this.h2);
    dataView.setUint32(12, this.h3);
    dataView.setUint32(16, this.h4);
    dataView.setUint32(20, this.h5);
    dataView.setUint32(24, this.h6);
    if (!this.is224) {
      dataView.setUint32(28, this.h7);
    }
    return buffer;
  };

  function HmacSha256(key, is224, sharedMemory) 
  {
    var i,
      type = typeof key;
    if (type === "string") {
      var bytes = [],
        length = key.length,
        index = 0,
        code;
      for (i = 0; i < length; ++i) {
        code = key.charCodeAt(i);
        if (code < 0x80) {
          bytes[index++] = code;
        } 
        else if (code < 0x800) {
          bytes[index++] = 0xc0 | (code >>> 6);
          bytes[index++] = 0x80 | (code & 0x3f);
        } 
        else if (code < 0xd800 || code >= 0xe000) {
          bytes[index++] = 0xe0 | (code >>> 12);
          bytes[index++] = 0x80 | ((code >>> 6) & 0x3f);
          bytes[index++] = 0x80 | (code & 0x3f);
        } 
        else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));
          bytes[index++] = 0xf0 | (code >>> 18);
          bytes[index++] = 0x80 | ((code >>> 12) & 0x3f);
          bytes[index++] = 0x80 | ((code >>> 6) & 0x3f);
          bytes[index++] = 0x80 | (code & 0x3f);
        }
      }
      key = bytes;
    } 
    
    else 
    {
      if (type === "object") {
        if (key === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
          key = new Uint8Array(key);
        } else if (!Array.isArray(key)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
    }

    if (key.length > 64) {
      key = new Sha256(is224, true).update(key).array();
    }

    var oKeyPad = [],
      iKeyPad = [];
    for (i = 0; i < 64; ++i) {
      var b = key[i] || 0;
      oKeyPad[i] = 0x5c ^ b;
      iKeyPad[i] = 0x36 ^ b;
    }

    Sha256.call(this, is224, sharedMemory);

    this.update(iKeyPad);
    this.oKeyPad = oKeyPad;
    this.inner = true;
    this.sharedMemory = sharedMemory;
  }
  HmacSha256.prototype = new Sha256();

  HmacSha256.prototype.finalize = function () 
  {
    Sha256.prototype.finalize.call(this);
    if (this.inner) {
      this.inner = false;
      var innerHash = this.array();
      Sha256.call(this, this.is224, this.sharedMemory);
      this.update(this.oKeyPad);
      this.update(innerHash);
      Sha256.prototype.finalize.call(this);
    }
  };

  var exports = createMethod();
  exports.sha256 = exports;
  exports.sha224 = createMethod(true);
  exports.sha256.hmac = createHmacMethod();
  exports.sha224.hmac = createHmacMethod(true);

  if (COMMON_JS) 
  {
    module.exports = exports;
  } else {
    root.sha256 = exports.sha256;
    root.sha224 = exports.sha224;
    if (AMD) {
      define(function () {
        return exports;
      });
    }
  }
})();
